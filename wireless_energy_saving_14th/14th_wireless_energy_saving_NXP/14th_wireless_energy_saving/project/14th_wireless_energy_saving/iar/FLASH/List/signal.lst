###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       08/Jul/2019  02:43:03
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\app\signal\src\signal.c
#    Command line =  
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\app\signal\src\signal.c
#        -D LPLD_K60 -lCN
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\FLASH\List
#        -lB
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\FLASH\List
#        -o
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\CPU\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\common\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\LPLD\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\LPLD\HW\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\FatFs\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\FatFs\option\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\USB\common\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\USB\driver\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\USB\descriptor\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\USB\class\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\control\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\debug\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\device\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\signal\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\system\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\control\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\debug\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\device\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\signal\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\system\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\drivers\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\drivers\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\charge\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\charge\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\LPLD\FUNC\
#        -Ol -I "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\FLASH\List\signal.lst
#    Object file  =  
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\FLASH\Obj\signal.o
#
###############################################################################

D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\app\signal\src\signal.c
      1          /*=============================================
      2              @file         signal.c
      3              @brief        信号处理
      4              @programmer   Beyond Hsueh
      5          =============================================*/
      6          
      7          #include "signal.h"
      8          
      9          /*===============================================================
     10                  @note      黄金榜上，偶失龙头望。
     11                             明代暂遗贤，如何向。
     12                             未遂风云便，争不恣狂荡，何须论得丧。
     13                             才子词人，自是白衣卿相。
     14                             烟花巷陌，依约丹青屏障，
     15                             幸有意中人，堪寻访，
     16                             且恁偎红倚翠，风流事，平生畅，青春都一饷。
     17                             忍把浮名，换了浅斟低唱。
     18          ==================================================================*/ 
     19          

   \                                 In section .bss, align 4
     20          static int16 si_inductor_value_history[NUM_INDUCTOR][NUM_INDUCTOR_HISTORY] = {0};//电感信号历史值 -- 滤波后 -- 用于信号处理,只在防跳变滤波器中更新
   \                     si_inductor_value_history:
   \   00000000                      DS8 40
     21          
     22          /*===============================================================
     23          	@brief     信号中断调用函数
     24                  @note      两横两竖特征变化最明显基本可以解决大部分问题
     25          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
     26          void Signal_Control()
     27          {
   \                     Signal_Control: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     28            
     29              Get_Signal_Value();
   \   00000002   0x.... 0x....      BL       Get_Signal_Value
     30              
     31              if(!guc_obstacle_flag)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable9
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE.N    ??Signal_Control_0
     32              {
     33                  Get_Sensor_Offset(gi_inductor_value);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000014   0x.... 0x....      BL       Get_Sensor_Offset
     34              }
     35          
     36              gl_car_speed_set = gl_speed_straight;
   \                     ??Signal_Control_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable7
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000022   0x6008             STR      R0,[R1, #+0]
     37          
     38              static int32 stopline_distance;//检测到停车线时行驶路程
     39          
     40              Get_Signal_Derivative();
   \   00000024   0x.... 0x....      BL       Get_Signal_Derivative
     41              gi_x_signal_gradient = gi_signal_gradient[X_LEFT] + gi_signal_gradient[X_RIGHT];
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   0000002C   0x8840             LDRH     R0,[R0, #+2]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \   00000032   0x88C9             LDRH     R1,[R1, #+6]
   \   00000034   0x1808             ADDS     R0,R1,R0
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \   0000003A   0x8008             STRH     R0,[R1, #+0]
     42              gi_m_signal_gradient = gi_signal_gradient[M_BACK];
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   00000040   0x8880             LDRH     R0,[R0, #+4]
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable7_2
   \   00000046   0x8008             STRH     R0,[R1, #+0]
     43              gi_y_signal_gradient = gi_signal_gradient[T_LEFT] + gi_signal_gradient[T_RIGHT];
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   0000004C   0x8800             LDRH     R0,[R0, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \   00000052   0x8909             LDRH     R1,[R1, #+8]
   \   00000054   0x1808             ADDS     R0,R1,R0
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable8_1
   \   0000005A   0x8008             STRH     R0,[R1, #+0]
     44              
     45              if(!guc_obstacle_flag)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD101             BNE.N    ??Signal_Control_1
     46              {
     47                  Distinguish_Obstacle();
   \   00000066   0x.... 0x....      BL       Distinguish_Obstacle
     48              }
     49          
     50              if((guc_car_run_flag == CAR_RUN) && (gl_car_running_distance > 3))
   \                     ??Signal_Control_1: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x2801             CMP      R0,#+1
   \   00000072   0xD169             BNE.N    ??Signal_Control_2
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x2804             CMP      R0,#+4
   \   0000007C   0xDB64             BLT.N    ??Signal_Control_2
     51              {
     52                  switch(guc_distinction_flag)     //当已经识别到一种元素后，停止识别其他元素
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000082   0x7800             LDRB     R0,[R0, #+0]
   \   00000084   0x2801             CMP      R0,#+1
   \   00000086   0xD006             BEQ.N    ??Signal_Control_3
   \   00000088   0x2803             CMP      R0,#+3
   \   0000008A   0xD019             BEQ.N    ??Signal_Control_4
   \   0000008C   0x2804             CMP      R0,#+4
   \   0000008E   0xD01D             BEQ.N    ??Signal_Control_5
   \   00000090   0x2805             CMP      R0,#+5
   \   00000092   0xD02B             BEQ.N    ??Signal_Control_6
   \   00000094   0xE030             B.N      ??Signal_Control_7
     53                  {
     54                    case GENERAL:
     55                      guc_lost_signal_flag = Judge_Lost_Signal();//丢线识别
   \                     ??Signal_Control_3: (+1)
   \   00000096   0x.... 0x....      BL       Judge_Lost_Signal
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable8_3
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
     56              //        guc_curve_flag = Judge_Curve();//弯道识别
     57              //        guc_straight_flag = Judge_Straight();//直道识别
     58                      guc_slope_state = Judge_Slope();//坡道识别
   \   000000A0   0x.... 0x....      BL       Judge_Slope
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000000A8   0x7008             STRB     R0,[R1, #+0]
     59              //        guc_crucifix_flag = Judge_Crucifix();//十字识别
     60                      guc_annulus_state = Judge_Annulus();//圆环识别
   \   000000AA   0x.... 0x....      BL       Judge_Annulus
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   000000B2   0x7008             STRB     R0,[R1, #+0]
     61                      guc_obstacle_state = Jugde_Obstacle();//路障识别
   \   000000B4   0x.... 0x....      BL       Jugde_Obstacle
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   000000BC   0x7008             STRB     R0,[R1, #+0]
     62                      break;
   \   000000BE   0xE034             B.N      ??Signal_Control_8
     63                    case ANNULUS:
     64                      guc_annulus_state = Judge_Annulus();//圆环识别
   \                     ??Signal_Control_4: (+1)
   \   000000C0   0x.... 0x....      BL       Judge_Annulus
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   000000C8   0x7008             STRB     R0,[R1, #+0]
     65              //        guc_lost_signal_flag = Judge_Lost_Signal();//丢线识别
     66              //        guc_obstacle_state = Jugde_Obstacle();//路障识别
     67                      break;
   \   000000CA   0xE02E             B.N      ??Signal_Control_8
     68                    case SLOPE:
     69                      guc_slope_state = Judge_Slope();//坡道识别
   \                     ??Signal_Control_5: (+1)
   \   000000CC   0x.... 0x....      BL       Judge_Slope
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000000D4   0x7008             STRB     R0,[R1, #+0]
     70              //        guc_lost_signal_flag = Judge_Lost_Signal();//丢线识别
     71              //        guc_curve_flag = Judge_Curve();//弯道识别
     72              //        guc_crucifix_flag = Judge_Crucifix();//十字识别
     73                      guc_annulus_state = Judge_Annulus();//圆环识别
   \   000000D6   0x.... 0x....      BL       Judge_Annulus
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   000000DE   0x7008             STRB     R0,[R1, #+0]
     74                      guc_obstacle_state = Jugde_Obstacle();//路障识别
   \   000000E0   0x.... 0x....      BL       Jugde_Obstacle
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   000000E8   0x7008             STRB     R0,[R1, #+0]
     75                      break;
   \   000000EA   0xE01E             B.N      ??Signal_Control_8
     76                    case OBSTACLE:
     77                      guc_obstacle_state = Jugde_Obstacle();//路障识别
   \                     ??Signal_Control_6: (+1)
   \   000000EC   0x.... 0x....      BL       Jugde_Obstacle
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
     78                      break;        
   \   000000F6   0xE018             B.N      ??Signal_Control_8
     79                    default :
     80                      guc_lost_signal_flag = Judge_Lost_Signal();//丢线识别
   \                     ??Signal_Control_7: (+1)
   \   000000F8   0x.... 0x....      BL       Judge_Lost_Signal
   \   000000FC   0x.... 0x....      LDR.W    R1,??DataTable8_3
   \   00000100   0x7008             STRB     R0,[R1, #+0]
     81              //        guc_curve_flag = Judge_Curve();//弯道识别
     82              //        guc_straight_flag = Judge_Straight();//直道识别
     83                      guc_crucifix_flag = Judge_Crucifix();//十字识别
   \   00000102   0x.... 0x....      BL       Judge_Crucifix
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable9_4
   \   0000010A   0x7008             STRB     R0,[R1, #+0]
     84                      guc_slope_state = Judge_Slope();//坡道识别
   \   0000010C   0x.... 0x....      BL       Judge_Slope
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   00000114   0x7008             STRB     R0,[R1, #+0]
     85                      guc_annulus_state = Judge_Annulus();//圆环识别
   \   00000116   0x.... 0x....      BL       Judge_Annulus
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   0000011E   0x7008             STRB     R0,[R1, #+0]
     86                      guc_obstacle_state = Jugde_Obstacle();//路障识别
   \   00000120   0x.... 0x....      BL       Jugde_Obstacle
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   00000128   0x7008             STRB     R0,[R1, #+0]
     87                      break;
     88                  }
     89                  
     90                  if((guc_distinction_flag == NORMAL) && (guc_straight_flag))    //直道标定
   \                     ??Signal_Control_8: (+1)
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   0000012E   0x7800             LDRB     R0,[R0, #+0]
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD107             BNE.N    ??Signal_Control_9
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000138   0x7800             LDRB     R0,[R0, #+0]
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD002             BEQ.N    ??Signal_Control_9
     91                  {
     92                      Calibrate_Once();
   \   0000013E   0x.... 0x....      BL       Calibrate_Once
   \   00000142   0xE001             B.N      ??Signal_Control_2
     93                  }
     94                  else
     95                  {
     96                      End_Calibration();
   \                     ??Signal_Control_9: (+1)
   \   00000144   0x.... 0x....      BL       End_Calibration
     97                  }
     98                  
     99              }
    100             
    101          
    102          
    103              
    104              if(gl_voltage_input > 20000)    //经过发射线圈,不识别特殊元素
   \                     ??Signal_Control_2: (+1)
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000014C   0x6800             LDR      R0,[R0, #+0]
   \   0000014E   0xF644 0x6121      MOVW     R1,#+20001
   \   00000152   0x4288             CMP      R0,R1
   \   00000154   0xDB0B             BLT.N    ??Signal_Control_10
    105              {
    106                  guc_slope_state = 0;
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   0000015C   0x7008             STRB     R0,[R1, #+0]
    107                  guc_annulus_state = 0;
   \   0000015E   0x2000             MOVS     R0,#+0
   \   00000160   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   00000164   0x7008             STRB     R0,[R1, #+0]
    108                  guc_obstacle_state = 0;
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   0000016C   0x7008             STRB     R0,[R1, #+0]
    109          //        gl_car_error = 0;
    110              }
    111              
    112              if(guc_obstacle_state)
   \                     ??Signal_Control_10: (+1)
   \   0000016E   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   00000172   0x7800             LDRB     R0,[R0, #+0]
   \   00000174   0x2800             CMP      R0,#+0
   \   00000176   0xD015             BEQ.N    ??Signal_Control_11
    113              {
    114                  if(guc_obstacle_state%2)
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   0000017C   0x7800             LDRB     R0,[R0, #+0]
   \   0000017E   0x2102             MOVS     R1,#+2
   \   00000180   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000184   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   00000188   0x2800             CMP      R0,#+0
   \   0000018A   0xD002             BEQ.N    ??Signal_Control_12
    115                  {
    116                      Beep_On();
   \   0000018C   0x.... 0x....      BL       Beep_On
   \   00000190   0xE001             B.N      ??Signal_Control_13
    117                  }
    118                  else
    119                  {
    120                      Beep_Off();
   \                     ??Signal_Control_12: (+1)
   \   00000192   0x.... 0x....      BL       Beep_Off
    121                  }
    122                  
    123                  guc_distinction_flag = OBSTACLE;
   \                     ??Signal_Control_13: (+1)
   \   00000196   0x2005             MOVS     R0,#+5
   \   00000198   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   0000019C   0x7008             STRB     R0,[R1, #+0]
    124                  
    125                  Obstacle_Process();
   \   0000019E   0x.... 0x....      BL       Obstacle_Process
   \   000001A2   0xE036             B.N      ??Signal_Control_14
    126              }
    127              else if(guc_annulus_state)//环岛
   \                     ??Signal_Control_11: (+1)
   \   000001A4   0x.... 0x....      LDR.W    R0,??DataTable9_2
   \   000001A8   0x7800             LDRB     R0,[R0, #+0]
   \   000001AA   0x2800             CMP      R0,#+0
   \   000001AC   0xD015             BEQ.N    ??Signal_Control_15
    128              {
    129                  if(guc_annulus_state%2)
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable9_2
   \   000001B2   0x7800             LDRB     R0,[R0, #+0]
   \   000001B4   0x2102             MOVS     R1,#+2
   \   000001B6   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   000001BA   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xD002             BEQ.N    ??Signal_Control_16
    130                  {
    131                      Beep_On();
   \   000001C2   0x.... 0x....      BL       Beep_On
   \   000001C6   0xE001             B.N      ??Signal_Control_17
    132                  }
    133                  else
    134                  {
    135                      Beep_Off();
   \                     ??Signal_Control_16: (+1)
   \   000001C8   0x.... 0x....      BL       Beep_Off
    136                  }
    137                  
    138                  guc_distinction_flag = ANNULUS;
   \                     ??Signal_Control_17: (+1)
   \   000001CC   0x2003             MOVS     R0,#+3
   \   000001CE   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   000001D2   0x7008             STRB     R0,[R1, #+0]
    139                  
    140                  Annulus_Process();
   \   000001D4   0x.... 0x....      BL       Annulus_Process
   \   000001D8   0xE01B             B.N      ??Signal_Control_14
    141              }
    142              else if(guc_slope_state)
   \                     ??Signal_Control_15: (+1)
   \   000001DA   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \   000001DE   0x7800             LDRB     R0,[R0, #+0]
   \   000001E0   0x2800             CMP      R0,#+0
   \   000001E2   0xD010             BEQ.N    ??Signal_Control_18
    143              {
    144                  if(guc_slope_state == ON_RAMP)
   \   000001E4   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \   000001E8   0x7800             LDRB     R0,[R0, #+0]
   \   000001EA   0x2803             CMP      R0,#+3
   \   000001EC   0xD102             BNE.N    ??Signal_Control_19
    145                  {
    146                      Beep_Off();
   \   000001EE   0x.... 0x....      BL       Beep_Off
   \   000001F2   0xE001             B.N      ??Signal_Control_20
    147                  }
    148                  else
    149                  {
    150                      Beep_On();
   \                     ??Signal_Control_19: (+1)
   \   000001F4   0x.... 0x....      BL       Beep_On
    151                  }
    152                  guc_distinction_flag = SLOPE;
   \                     ??Signal_Control_20: (+1)
   \   000001F8   0x2004             MOVS     R0,#+4
   \   000001FA   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   000001FE   0x7008             STRB     R0,[R1, #+0]
    153          
    154                  Slope_Process();
   \   00000200   0x.... 0x....      BL       Slope_Process
   \   00000204   0xE005             B.N      ??Signal_Control_14
    155              }
    156          //    else if(guc_lost_signal_flag) //丢信号
    157          //    {
    158          //        Lost_Signal_Process();
    159          //        Beep_On();
    160          //    }
    161          //    else if(guc_crucifix_flag)    //十字
    162          //    {
    163          //        Beep_On();
    164          //        guc_distinction_flag = CRUCIFIX;
    165          //        Crucifix_Process();
    166          //    }
    167              else    //正常
    168              {
    169                  guc_distinction_flag = GENERAL;
   \                     ??Signal_Control_18: (+1)
   \   00000206   0x2001             MOVS     R0,#+1
   \   00000208   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   0000020C   0x7008             STRB     R0,[R1, #+0]
    170                  Beep_Off();
   \   0000020E   0x.... 0x....      BL       Beep_Off
    171                  //General_Process();
    172              }
    173              
    174          
    175              
    176              /*****************     自动停车检测，后期投入使用     *********************/
    177              if((guc_reed_state_value > 0) && (gul_time_start > 100000) && (gl_car_running_distance > gl_car_destination_distance))
   \                     ??Signal_Control_14: (+1)
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   00000216   0x7800             LDRB     R0,[R0, #+0]
   \   00000218   0x2800             CMP      R0,#+0
   \   0000021A   0xD012             BEQ.N    ??Signal_Control_21
   \   0000021C   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \   00000220   0x6800             LDR      R0,[R0, #+0]
   \   00000222   0x.... 0x....      LDR.W    R1,??DataTable11_5  ;; 0x186a1
   \   00000226   0x4288             CMP      R0,R1
   \   00000228   0xD30B             BCC.N    ??Signal_Control_21
   \   0000022A   0x.... 0x....      LDR.W    R0,??DataTable11_6
   \   0000022E   0x6800             LDR      R0,[R0, #+0]
   \   00000230   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000234   0x6809             LDR      R1,[R1, #+0]
   \   00000236   0x4288             CMP      R0,R1
   \   00000238   0xDA03             BGE.N    ??Signal_Control_21
    178              {
    179                  guc_destination_flag = 1;
   \   0000023A   0x2001             MOVS     R0,#+1
   \   0000023C   0x.... 0x....      LDR.W    R1,??DataTable11_7
   \   00000240   0x7008             STRB     R0,[R1, #+0]
    180              }
    181              
    182              if(guc_destination_flag)
   \                     ??Signal_Control_21: (+1)
   \   00000242   0x.... 0x....      LDR.W    R0,??DataTable11_7
   \   00000246   0x7800             LDRB     R0,[R0, #+0]
   \   00000248   0x2800             CMP      R0,#+0
   \   0000024A   0xD01F             BEQ.N    ??Signal_Control_22
    183              {
    184                  if(stopline_distance == 0)
   \   0000024C   0x.... 0x....      LDR.W    R0,??DataTable11_8
   \   00000250   0x6800             LDR      R0,[R0, #+0]
   \   00000252   0x2800             CMP      R0,#+0
   \   00000254   0xD106             BNE.N    ??Signal_Control_23
    185                  {
    186                      stopline_distance = gl_car_running_distance;
   \   00000256   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000025A   0x6800             LDR      R0,[R0, #+0]
   \   0000025C   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \   00000260   0x6008             STR      R0,[R1, #+0]
   \   00000262   0xE013             B.N      ??Signal_Control_22
    187                  }
    188                  else if(gl_car_running_distance - stopline_distance > 100)
   \                     ??Signal_Control_23: (+1)
   \   00000264   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000268   0x6800             LDR      R0,[R0, #+0]
   \   0000026A   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \   0000026E   0x6809             LDR      R1,[R1, #+0]
   \   00000270   0x1A40             SUBS     R0,R0,R1
   \   00000272   0x2865             CMP      R0,#+101
   \   00000274   0xDB08             BLT.N    ??Signal_Control_24
    189                  {
    190                      gl_car_speed_set = 0;
   \   00000276   0x2000             MOVS     R0,#+0
   \   00000278   0x.... 0x....      LDR.W    R1,??DataTable8
   \   0000027C   0x6008             STR      R0,[R1, #+0]
    191                      guc_car_run_flag = 0;
   \   0000027E   0x2000             MOVS     R0,#+0
   \   00000280   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   00000284   0x7008             STRB     R0,[R1, #+0]
   \   00000286   0xE001             B.N      ??Signal_Control_22
    192                  }
    193                  else
    194                  {
    195                      Beep_On();
   \                     ??Signal_Control_24: (+1)
   \   00000288   0x.... 0x....      BL       Beep_On
    196                  }
    197              }
    198              
    199              if(gl_car_running_distance > gl_car_stopline_distance)
   \                     ??Signal_Control_22: (+1)
   \   0000028C   0x.... 0x....      LDR.W    R0,??DataTable11_9
   \   00000290   0x6800             LDR      R0,[R0, #+0]
   \   00000292   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000296   0x6809             LDR      R1,[R1, #+0]
   \   00000298   0x4288             CMP      R0,R1
   \   0000029A   0xDA03             BGE.N    ??Signal_Control_25
    200              {
    201                      guc_car_run_flag = 0;
   \   0000029C   0x2000             MOVS     R0,#+0
   \   0000029E   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   000002A2   0x7008             STRB     R0,[R1, #+0]
    202              }
    203          
    204          }
   \                     ??Signal_Control_25: (+1)
   \   000002A4   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 4
   \                     `Signal_Control::stopline_distance`:
   \   00000000                      DS8 4
    205          
    206          
    207          /*===============================================================
    208          	@brief     获取电感AD转换值
    209          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    210          void Get_Inductor_Value()
    211          {   
   \                     Get_Inductor_Value: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    212              vint16 inductor_value[NUM_INDUCTOR];
    213              Inductor_All_Get(inductor_value);
   \   00000002   0x4668             MOV      R0,SP
   \   00000004   0x.... 0x....      BL       Inductor_All_Get
    214              
    215          #ifdef T_LEFT
    216                 gi_inductor_adc[T_LEFT] = inductor_value[T_LEFT];
   \   00000008   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable11_10
   \   00000010   0x8008             STRH     R0,[R1, #+0]
    217                 gi_inductor_value[T_LEFT] = inductor_value[T_LEFT];
   \   00000012   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000001A   0x8008             STRH     R0,[R1, #+0]
    218          #endif
    219          
    220          #ifdef T_RIGHT
    221                 gi_inductor_adc[T_RIGHT] = inductor_value[T_RIGHT];
   \   0000001C   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable11_10
   \   00000024   0x8108             STRH     R0,[R1, #+8]
    222                 gi_inductor_value[T_RIGHT] = inductor_value[T_RIGHT];
   \   00000026   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000002E   0x8108             STRH     R0,[R1, #+8]
    223          #endif
    224                  
    225          #ifdef M_BACK
    226                 gi_inductor_adc[M_BACK] = inductor_value[M_BACK];
   \   00000030   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable11_10
   \   00000038   0x8088             STRH     R0,[R1, #+4]
    227                 gi_inductor_value[M_BACK] = inductor_value[M_BACK];
   \   0000003A   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000042   0x8088             STRH     R0,[R1, #+4]
    228          #endif
    229          
    230          #ifdef M_FRONT
    231                 gi_inductor_adc[M_FRONT] = inductor_value[M_FRONT]; 
    232                 gi_inductor_value[M_FRONT] = inductor_value[M_FRONT];
    233          #endif 
    234          
    235          #ifdef X_LEFT
    236                 gi_inductor_adc[X_LEFT] = inductor_value[X_LEFT];
   \   00000044   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable11_10
   \   0000004C   0x8048             STRH     R0,[R1, #+2]
    237                 gi_inductor_value[X_LEFT] = inductor_value[X_LEFT];
   \   0000004E   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000056   0x8048             STRH     R0,[R1, #+2]
    238          #endif
    239          
    240          #ifdef X_RIGHT
    241                 gi_inductor_adc[X_RIGHT] = inductor_value[X_RIGHT]; 
   \   00000058   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable11_10
   \   00000060   0x80C8             STRH     R0,[R1, #+6]
    242                 gi_inductor_value[X_RIGHT] = inductor_value[X_RIGHT];
   \   00000062   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000006A   0x80C8             STRH     R0,[R1, #+6]
    243          #endif 
    244                 
    245          }
   \   0000006C   0xBD07             POP      {R0-R2,PC}       ;; return
    246          
    247          /*===============================================================
    248          	@brief     偏离赛道危险情况停车函数
    249          	@note      电感值跳变判断后停车保护
    250          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    251          void Stop_Danger_Lost_Signals(vint16 p_inductor_value[])
    252          {
    253              int flag = 0, i = 0;
   \                     Stop_Danger_Lost_Signals: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x2200             MOVS     R2,#+0
    254              static int danger_count = 0;
    255              
    256              if (guc_car_run_flag == FLAG_ON)
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable11_2
   \   00000008   0x7812             LDRB     R2,[R2, #+0]
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xD125             BNE.N    ??Stop_Danger_Lost_Signals_0
    257              {
    258                  for (i = 0; i < NUM_INDUCTOR; i++)
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xE001             B.N      ??Stop_Danger_Lost_Signals_1
    259                  {
    260                      if (p_inductor_value[i] <= 10)
    261                      {
    262                          flag++;
   \                     ??Stop_Danger_Lost_Signals_2: (+1)
   \   00000012   0x1C49             ADDS     R1,R1,#+1
    263                      }
   \   00000014   0x1C52             ADDS     R2,R2,#+1
   \                     ??Stop_Danger_Lost_Signals_1: (+1)
   \   00000016   0x2A05             CMP      R2,#+5
   \   00000018   0xDA03             BGE.N    ??Stop_Danger_Lost_Signals_3
   \   0000001A   0xF930 0x3012      LDRSH    R3,[R0, R2, LSL #+1]
   \   0000001E   0x2B0B             CMP      R3,#+11
   \   00000020   0xDBF7             BLT.N    ??Stop_Danger_Lost_Signals_2
    264                      else
    265                      {
    266                          break;
    267                      }
    268                  }
    269          
    270                  //所有电感值信号均 < 1
    271                  if (flag >= NUM_INDUCTOR-1)
   \                     ??Stop_Danger_Lost_Signals_3: (+1)
   \   00000022   0x2904             CMP      R1,#+4
   \   00000024   0xDB07             BLT.N    ??Stop_Danger_Lost_Signals_4
    272                  {
    273                      danger_count++;   
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable11_11
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable11_11
   \   00000032   0x6008             STR      R0,[R1, #+0]
   \   00000034   0xE003             B.N      ??Stop_Danger_Lost_Signals_5
    274                  }
    275                  else
    276                  {
    277                      danger_count = 0;
   \                     ??Stop_Danger_Lost_Signals_4: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable11_11
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    278                  }
    279              
    280                  if (danger_count >= 200) //持续，停车
   \                     ??Stop_Danger_Lost_Signals_5: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable11_11
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x28C8             CMP      R0,#+200
   \   00000046   0xDB0C             BLT.N    ??Stop_Danger_Lost_Signals_6
    281                  {
    282                      danger_count = 201;
   \   00000048   0x20C9             MOVS     R0,#+201
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable11_11
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    283                      guc_car_run_flag = FLAG_OFF;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   00000056   0x7008             STRB     R0,[R1, #+0]
   \   00000058   0xE003             B.N      ??Stop_Danger_Lost_Signals_6
    284                  } 
    285              }
    286              else
    287              {
    288                  danger_count = 0;
   \                     ??Stop_Danger_Lost_Signals_0: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable11_11
   \   00000060   0x6008             STR      R0,[R1, #+0]
    289              }  
    290          }
   \                     ??Stop_Danger_Lost_Signals_6: (+1)
   \   00000062   0x4770             BX       LR               ;; return

   \                                 In section .bss, align 4
   \                     `Stop_Danger_Lost_Signals::danger_count`:
   \   00000000                      DS8 4
    291          
    292          /*===============================================================
    293          	@brief     电感值防跳变最小二乘法滤波器
    294          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    295          void Filter_Inductor_Value(vint16 inductor_value[])
    296          {
   \                     Filter_Inductor_Value: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    297              static int16 last_inductor_value[NUM_INDUCTOR] = {0};
    298              //电感值跳变计数，超过一定次数，退出电感值跳变状态，保护。
    299              static int inductor_value_jump_times[NUM_INDUCTOR] = {0};
    300              int i = 0, j = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x2000             MOVS     R0,#+0
    301           
    302              for(i = 0; i < NUM_INDUCTOR; i++)
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0xE008             B.N      ??Filter_Inductor_Value_0
    303              {
    304          	last_inductor_value[i] = si_inductor_value_history[i][0];
   \                     ??Filter_Inductor_Value_1: (+1)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable11_12
   \   00000010   0xF830 0x0035      LDRH     R0,[R0, R5, LSL #+3]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \   00000018   0xF821 0x0015      STRH     R0,[R1, R5, LSL #+1]
    305              }
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Filter_Inductor_Value_0: (+1)
   \   0000001E   0x2D05             CMP      R5,#+5
   \   00000020   0xDBF4             BLT.N    ??Filter_Inductor_Value_1
    306              
    307              for(i = 0; i < NUM_INDUCTOR; i++)
   \   00000022   0x2500             MOVS     R5,#+0
   \   00000024   0xE00B             B.N      ??Filter_Inductor_Value_2
    308              {
    309          	if(inductor_value[i] <= last_inductor_value[i])
    310          	{
    311                      if(inductor_value[i] < (last_inductor_value[i] - 15))
    312                      {//用滤波后的电感值数组滤波
    313                          last_inductor_value[i] = least_squares_value(si_inductor_value_history[i]);
    314          		inductor_value_jump_times[i] ++;
    315                          
    316                          //跳变超过一定次数，认为当前电感值为正确值
    317          		if(inductor_value_jump_times[i] >= JUMP_MAX_TIMES)
    318          		{
    319                              last_inductor_value[i] = inductor_value[i];
    320                              inductor_value_jump_times[i] = 0;
    321          		}
    322                      }
    323                      else if(inductor_value[i] < (last_inductor_value[i] - 10))
    324                      {
    325                          last_inductor_value[i] = last_inductor_value[i] - 5;
    326          		inductor_value_jump_times[i] = 0;
    327                      }
    328                      else
    329                      {
    330          		last_inductor_value[i] = inductor_value[i];
    331          		inductor_value_jump_times[i] = 0;
    332                      }
    333                  }
    334                  else
    335                  {
    336                      if(inductor_value[i] > (last_inductor_value[i] + 15))
    337                      {
    338          		last_inductor_value[i] = least_squares_value(si_inductor_value_history[i]);
    339          		inductor_value_jump_times[i] ++;
    340          
    341          		if(inductor_value_jump_times[i] >= JUMP_MAX_TIMES)
    342          		{
    343                              last_inductor_value[i] = inductor_value[i];
    344                              inductor_value_jump_times[i] = 0;
    345          		}
    346                      }
    347                      else if(inductor_value[i] > (last_inductor_value[i] + 10))
    348                      {
    349                          last_inductor_value[i] = last_inductor_value[i] + 5;
    350                          inductor_value_jump_times[i] = 0;
    351                      }
    352                      else
    353                      {
    354          		last_inductor_value[i] = inductor_value[i];
   \                     ??Filter_Inductor_Value_3: (+1)
   \   00000026   0xF834 0x0015      LDRH     R0,[R4, R5, LSL #+1]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \   0000002E   0xF821 0x0015      STRH     R0,[R1, R5, LSL #+1]
    355          		inductor_value_jump_times[i] = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable11_14
   \   00000038   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
    356                      }
   \                     ??Filter_Inductor_Value_4: (+1)
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Filter_Inductor_Value_2: (+1)
   \   0000003E   0x2D05             CMP      R5,#+5
   \   00000040   0xF280 0x80A2      BGE.W    ??Filter_Inductor_Value_5
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable11_13
   \   00000048   0xF930 0x0015      LDRSH    R0,[R0, R5, LSL #+1]
   \   0000004C   0xF934 0x1015      LDRSH    R1,[R4, R5, LSL #+1]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xDB51             BLT.N    ??Filter_Inductor_Value_6
   \   00000054   0xF934 0x0015      LDRSH    R0,[R4, R5, LSL #+1]
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \   0000005C   0xF931 0x1015      LDRSH    R1,[R1, R5, LSL #+1]
   \   00000060   0x390F             SUBS     R1,R1,#+15
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xDA24             BGE.N    ??Filter_Inductor_Value_7
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable11_12
   \   0000006A   0xEB00 0x00C5      ADD      R0,R0,R5, LSL #+3
   \   0000006E   0x.... 0x....      BL       least_squares_value
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \   00000076   0xF821 0x0015      STRH     R0,[R1, R5, LSL #+1]
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable11_14
   \   0000007E   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable11_14
   \   00000088   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable11_14
   \   00000090   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000094   0x2804             CMP      R0,#+4
   \   00000096   0xDBD1             BLT.N    ??Filter_Inductor_Value_4
   \   00000098   0xF834 0x0015      LDRH     R0,[R4, R5, LSL #+1]
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \   000000A0   0xF821 0x0015      STRH     R0,[R1, R5, LSL #+1]
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable11_14
   \   000000AA   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   \   000000AE   0xE7C5             B.N      ??Filter_Inductor_Value_4
   \                     ??Filter_Inductor_Value_7: (+1)
   \   000000B0   0xF934 0x0015      LDRSH    R0,[R4, R5, LSL #+1]
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \   000000B8   0xF931 0x1015      LDRSH    R1,[R1, R5, LSL #+1]
   \   000000BC   0x390A             SUBS     R1,R1,#+10
   \   000000BE   0x4288             CMP      R0,R1
   \   000000C0   0xDA0E             BGE.N    ??Filter_Inductor_Value_8
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable11_13
   \   000000C6   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   000000CA   0x1F40             SUBS     R0,R0,#+5
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \   000000D0   0xF821 0x0015      STRH     R0,[R1, R5, LSL #+1]
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable11_14
   \   000000DA   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   \   000000DE   0xE7AD             B.N      ??Filter_Inductor_Value_4
   \                     ??Filter_Inductor_Value_8: (+1)
   \   000000E0   0xF834 0x0015      LDRH     R0,[R4, R5, LSL #+1]
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \   000000E8   0xF821 0x0015      STRH     R0,[R1, R5, LSL #+1]
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable11_14
   \   000000F2   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   \   000000F6   0xE7A1             B.N      ??Filter_Inductor_Value_4
   \                     ??Filter_Inductor_Value_6: (+1)
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable11_13
   \   000000FC   0xF930 0x0015      LDRSH    R0,[R0, R5, LSL #+1]
   \   00000100   0x300F             ADDS     R0,R0,#+15
   \   00000102   0xF934 0x1015      LDRSH    R1,[R4, R5, LSL #+1]
   \   00000106   0x4288             CMP      R0,R1
   \   00000108   0xDA25             BGE.N    ??Filter_Inductor_Value_9
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable11_12
   \   0000010E   0xEB00 0x00C5      ADD      R0,R0,R5, LSL #+3
   \   00000112   0x.... 0x....      BL       least_squares_value
   \   00000116   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \   0000011A   0xF821 0x0015      STRH     R0,[R1, R5, LSL #+1]
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable11_14
   \   00000122   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000126   0x1C40             ADDS     R0,R0,#+1
   \   00000128   0x.... 0x....      LDR.W    R1,??DataTable11_14
   \   0000012C   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable11_14
   \   00000134   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000138   0x2804             CMP      R0,#+4
   \   0000013A   0xF6FF 0xAF7F      BLT.W    ??Filter_Inductor_Value_4
   \   0000013E   0xF834 0x0015      LDRH     R0,[R4, R5, LSL #+1]
   \   00000142   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \   00000146   0xF821 0x0015      STRH     R0,[R1, R5, LSL #+1]
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0x.... 0x....      LDR.W    R1,??DataTable11_14
   \   00000150   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   \   00000154   0xE772             B.N      ??Filter_Inductor_Value_4
   \                     ??Filter_Inductor_Value_9: (+1)
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable11_13
   \   0000015A   0xF930 0x0015      LDRSH    R0,[R0, R5, LSL #+1]
   \   0000015E   0x300A             ADDS     R0,R0,#+10
   \   00000160   0xF934 0x1015      LDRSH    R1,[R4, R5, LSL #+1]
   \   00000164   0x4288             CMP      R0,R1
   \   00000166   0xF6BF 0xAF5E      BGE.W    ??Filter_Inductor_Value_3
   \   0000016A   0x.... 0x....      LDR.W    R0,??DataTable11_13
   \   0000016E   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000172   0x1D40             ADDS     R0,R0,#+5
   \   00000174   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \   00000178   0xF821 0x0015      STRH     R0,[R1, R5, LSL #+1]
   \   0000017C   0x2000             MOVS     R0,#+0
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable11_14
   \   00000182   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   \   00000186   0xE759             B.N      ??Filter_Inductor_Value_4
    357          	}
    358              }
    359              //更新电感值
    360              for(i = 0; i < NUM_INDUCTOR; i++)
   \                     ??Filter_Inductor_Value_5: (+1)
   \   00000188   0x2500             MOVS     R5,#+0
   \   0000018A   0xE006             B.N      ??Filter_Inductor_Value_10
    361              {
    362          	inductor_value[i] = last_inductor_value[i];
   \                     ??Filter_Inductor_Value_11: (+1)
   \   0000018C   0x.... 0x....      LDR.W    R0,??DataTable11_13
   \   00000190   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000194   0xF824 0x0015      STRH     R0,[R4, R5, LSL #+1]
    363              }
   \   00000198   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Filter_Inductor_Value_10: (+1)
   \   0000019A   0x2D05             CMP      R5,#+5
   \   0000019C   0xDBF6             BLT.N    ??Filter_Inductor_Value_11
    364              //更新历史电感值
    365              for(i = 0; i < NUM_INDUCTOR; i++)
   \   0000019E   0x2500             MOVS     R5,#+0
   \   000001A0   0xE017             B.N      ??Filter_Inductor_Value_12
    366              {
    367          	for(j = NUM_INDUCTOR_HISTORY-1; j >= 1; j--)
    368          	{			
    369                      si_inductor_value_history[i][j] = si_inductor_value_history[i][j-1];
   \                     ??Filter_Inductor_Value_13: (+1)
   \   000001A2   0x.... 0x....      LDR.W    R1,??DataTable11_12
   \   000001A6   0xEB01 0x01C5      ADD      R1,R1,R5, LSL #+3
   \   000001AA   0x.... 0x....      LDR.W    R2,??DataTable11_12
   \   000001AE   0xEB02 0x02C5      ADD      R2,R2,R5, LSL #+3
   \   000001B2   0xEB02 0x0240      ADD      R2,R2,R0, LSL #+1
   \   000001B6   0xF832 0x2C02      LDRH     R2,[R2, #-2]
   \   000001BA   0xF821 0x2010      STRH     R2,[R1, R0, LSL #+1]
    370          	}
   \   000001BE   0x1E40             SUBS     R0,R0,#+1
   \                     ??Filter_Inductor_Value_14: (+1)
   \   000001C0   0x2801             CMP      R0,#+1
   \   000001C2   0xDAEE             BGE.N    ??Filter_Inductor_Value_13
    371          	si_inductor_value_history[i][0] = inductor_value[i];
   \   000001C4   0xF834 0x0015      LDRH     R0,[R4, R5, LSL #+1]
   \   000001C8   0x.... 0x....      LDR.W    R1,??DataTable11_12
   \   000001CC   0xF821 0x0035      STRH     R0,[R1, R5, LSL #+3]
   \   000001D0   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Filter_Inductor_Value_12: (+1)
   \   000001D2   0x2D05             CMP      R5,#+5
   \   000001D4   0xDA01             BGE.N    ??Filter_Inductor_Value_15
   \   000001D6   0x2003             MOVS     R0,#+3
   \   000001D8   0xE7F2             B.N      ??Filter_Inductor_Value_14
    372              }
    373          }
   \                     ??Filter_Inductor_Value_15: (+1)
   \   000001DA   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .bss, align 4
   \                     `Filter_Inductor_Value::last_inductor_value`:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     `Filter_Inductor_Value::inductor_value_jump_times`:
   \   00000000                      DS8 20
    374          
    375          /*===============================================================
    376          	@brief     获取电感差比和
    377          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    378          void Get_Sensor_Offset(vint16 sensor_value[])
    379          {
   \                     Get_Sensor_Offset: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    380              //static int16  s_sensor_ad_value[NUM_INDUCTOR] = {0};//上次传感器的值
    381              int16 x0,x1,x2,x3;
    382              float  f_sensor_offset_x_temp = 0;
   \   00000004   0xF05F 0x0900      MOVS     R9,#+0
    383              float  f_sensor_offset_t_temp = 0;
   \   00000008   0xF05F 0x0800      MOVS     R8,#+0
    384              float  f_sensor_difference_t_temp = 0;    
   \   0000000C   0x2400             MOVS     R4,#+0
    385              //int  i = 0;
    386          
    387              //int16  x_sensor_value[NUM_INDUCTOR] = {0};
    388          
    389          //    x_sensor_value[0] = sensor_value[T_LEFT];      //X0
    390          //    x_sensor_value[1] = sensor_value[X_LEFT];      //X1
    391          //    x_sensor_value[2] = sensor_value[X_RIGHT];      //X2
    392          //    x_sensor_value[3] = sensor_value[T_RIGHT];      //X3 
    393              
    394              x0 = sensor_value[T_LEFT];      //X0
   \   0000000E   0xF9B0 0x4000      LDRSH    R4,[R0, #+0]
    395              x1 = sensor_value[X_LEFT];      //X1
   \   00000012   0xF9B0 0x5002      LDRSH    R5,[R0, #+2]
    396              x2 = sensor_value[X_RIGHT];      //X2
   \   00000016   0xF9B0 0x6006      LDRSH    R6,[R0, #+6]
    397              x3 = sensor_value[T_RIGHT];      //X3 
   \   0000001A   0xF9B0 0x7008      LDRSH    R7,[R0, #+8]
    398          
    399              //更新上次传感器的值，前已滤波
    400          //    for(i = 0; i < NUM_INDUCTOR; i++)
    401          //    { 
    402          //	if(x_sensor_value[i] < s_sensor_ad_value[i] - 5)
    403          //	{
    404          //            s_sensor_ad_value[i] = s_sensor_ad_value[i] - 3;
    405          //	}
    406          //	else if(x_sensor_value[i] > s_sensor_ad_value[i] + 5)
    407          //	{
    408          //            s_sensor_ad_value[i] = s_sensor_ad_value[i] + 3;
    409          //	}
    410          //	else
    411          //	{ 
    412          //            s_sensor_ad_value[i] = x_sensor_value[i];
    413          //	}
    414          //    }
    415          //    
    416          //    x0 = s_sensor_ad_value[0];
    417          //    x1 = s_sensor_ad_value[1];
    418              
    419              f_sensor_offset_t_temp = (float)(ORIGINAL_LINEAR_PROPORTION_T) * (float)(x0 - x3)/((float)(x0 + x3 + 1));
   \   0000001E   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000020   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000022   0x1BE0             SUBS     R0,R4,R7
   \   00000024   0x.... 0x....      BL       __aeabi_i2f
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable11_15  ;; 0x42c80000
   \   0000002C   0x.... 0x....      BL       __aeabi_fmul
   \   00000030   0x4680             MOV      R8,R0
   \   00000032   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000034   0xFA07 0xF084      SXTAH    R0,R7,R4
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0x.... 0x....      BL       __aeabi_i2f
   \   0000003E   0x0001             MOVS     R1,R0
   \   00000040   0x4640             MOV      R0,R8
   \   00000042   0x.... 0x....      BL       __aeabi_fdiv
   \   00000046   0x4680             MOV      R8,R0
    420              f_sensor_offset_x_temp = (float)(ORIGINAL_LINEAR_PROPORTION_X) * (float)(x1 - x2)/((float)(x2 + x1 + 1));
   \   00000048   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \   0000004A   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   0000004C   0x1BA8             SUBS     R0,R5,R6
   \   0000004E   0x.... 0x....      BL       __aeabi_i2f
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable11_16  ;; 0x43480000
   \   00000056   0x.... 0x....      BL       __aeabi_fmul
   \   0000005A   0x4681             MOV      R9,R0
   \   0000005C   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \   0000005E   0xFA05 0xF086      SXTAH    R0,R5,R6
   \   00000062   0x1C40             ADDS     R0,R0,#+1
   \   00000064   0x.... 0x....      BL       __aeabi_i2f
   \   00000068   0x0001             MOVS     R1,R0
   \   0000006A   0x4648             MOV      R0,R9
   \   0000006C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000070   0x4681             MOV      R9,R0
    421              f_sensor_difference_t_temp = (float)(ORIGINAL_LINEAR_PROPORTION_T) * (float)(x3 - x0)/((float)(x1 + x2 + 1));
   \   00000072   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000074   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000076   0x1B38             SUBS     R0,R7,R4
   \   00000078   0x.... 0x....      BL       __aeabi_i2f
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable11_15  ;; 0x42c80000
   \   00000080   0x.... 0x....      BL       __aeabi_fmul
   \   00000084   0x0004             MOVS     R4,R0
   \   00000086   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   00000088   0xFA06 0xF085      SXTAH    R0,R6,R5
   \   0000008C   0x1C40             ADDS     R0,R0,#+1
   \   0000008E   0x.... 0x....      BL       __aeabi_i2f
   \   00000092   0x0001             MOVS     R1,R0
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0x.... 0x....      BL       __aeabi_fdiv
   \   0000009A   0x0004             MOVS     R4,R0
    422          
    423              if((guc_direction_flag == LEFT)&&(f_sensor_offset_t_temp > 10))  //设置回差带，防止震荡
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable11_17
   \   000000A0   0x7800             LDRB     R0,[R0, #+0]
   \   000000A2   0x2802             CMP      R0,#+2
   \   000000A4   0xD10A             BNE.N    ??Get_Sensor_Offset_0
   \   000000A6   0x4640             MOV      R0,R8
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable11_18  ;; 0x41200001
   \   000000AC   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000B0   0xD804             BHI.N    ??Get_Sensor_Offset_0
    424              {
    425                  guc_direction_flag = RIGHT;
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable11_17
   \   000000B8   0x7008             STRB     R0,[R1, #+0]
   \   000000BA   0xE00E             B.N      ??Get_Sensor_Offset_1
    426              }
    427              else if((guc_direction_flag == RIGHT)&&(f_sensor_offset_t_temp < -10))
   \                     ??Get_Sensor_Offset_0: (+1)
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable11_17
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x2801             CMP      R0,#+1
   \   000000C4   0xD109             BNE.N    ??Get_Sensor_Offset_1
   \   000000C6   0x4640             MOV      R0,R8
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable11_19  ;; 0xc1200000
   \   000000CC   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D0   0xD203             BCS.N    ??Get_Sensor_Offset_1
    428              {
    429                  guc_direction_flag = LEFT;
   \   000000D2   0x2002             MOVS     R0,#+2
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable11_17
   \   000000D8   0x7008             STRB     R0,[R1, #+0]
    430              }
    431          
    432              gi_inductor_t_offset = (int16)((f_sensor_offset_t_temp * gui_t_weight)/100);
   \                     ??Get_Sensor_Offset_1: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable11_20
   \   000000DE   0x8800             LDRH     R0,[R0, #+0]
   \   000000E0   0x.... 0x....      BL       __aeabi_ui2f
   \   000000E4   0x4641             MOV      R1,R8
   \   000000E6   0x.... 0x....      BL       __aeabi_fmul
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable11_15  ;; 0x42c80000
   \   000000EE   0x.... 0x....      BL       __aeabi_fdiv
   \   000000F2   0x.... 0x....      BL       __aeabi_f2iz
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable11_21
   \   000000FA   0x8008             STRH     R0,[R1, #+0]
    433              gi_inductor_x_offset = (int16)((f_sensor_offset_x_temp * gui_x_weight)/100);
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable11_22
   \   00000100   0x8800             LDRH     R0,[R0, #+0]
   \   00000102   0x.... 0x....      BL       __aeabi_ui2f
   \   00000106   0x4649             MOV      R1,R9
   \   00000108   0x.... 0x....      BL       __aeabi_fmul
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable11_15  ;; 0x42c80000
   \   00000110   0x.... 0x....      BL       __aeabi_fdiv
   \   00000114   0x.... 0x....      BL       __aeabi_f2iz
   \   00000118   0x.... 0x....      LDR.W    R1,??DataTable11_23
   \   0000011C   0x8008             STRH     R0,[R1, #+0]
    434              gi_inductor_t_difference = (int16)((f_sensor_difference_t_temp * gui_t_div_weight)/100);
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable11_24
   \   00000122   0x8800             LDRH     R0,[R0, #+0]
   \   00000124   0x.... 0x....      BL       __aeabi_ui2f
   \   00000128   0x0021             MOVS     R1,R4
   \   0000012A   0x.... 0x....      BL       __aeabi_fmul
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable11_15  ;; 0x42c80000
   \   00000132   0x.... 0x....      BL       __aeabi_fdiv
   \   00000136   0x.... 0x....      BL       __aeabi_f2iz
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable11_25
   \   0000013E   0x8008             STRH     R0,[R1, #+0]
    435              
    436              gl_car_error = gi_inductor_x_offset;
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable11_23
   \   00000144   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000148   0x.... 0x....      LDR.W    R1,??DataTable11_26
   \   0000014C   0x6008             STR      R0,[R1, #+0]
    437              
    438          }
   \   0000014E   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    439          
    440          /*===============================================================
    441          	@brief     校准信号，消除零漂
    442          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    443          void Criterion_Signal(vint16 inductor_value[])
    444          {
   \                     Criterion_Signal: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
    445              int16 inductor_value_x1,inductor_value_x2;
    446              int16 inductor_value_y1,inductor_value_y2;
    447              int16 inductor_value_m1;
    448              
    449              inductor_value_x1 = inductor_value[X_LEFT];
   \   00000006   0xF9B4 0x9002      LDRSH    R9,[R4, #+2]
    450              inductor_value_x2 = inductor_value[X_RIGHT];
   \   0000000A   0xF9B4 0x5006      LDRSH    R5,[R4, #+6]
    451              inductor_value_y1 = inductor_value[T_LEFT];
   \   0000000E   0xF9B4 0x6000      LDRSH    R6,[R4, #+0]
    452              inductor_value_y2 = inductor_value[T_RIGHT];
   \   00000012   0xF9B4 0x7008      LDRSH    R7,[R4, #+8]
    453              inductor_value_m1 = inductor_value[M_BACK];
   \   00000016   0xF9B4 0x8004      LDRSH    R8,[R4, #+4]
    454              
    455              inductor_value_x1 -= CRITERION_SIGNAL;
   \   0000001A   0xF1B9 0x0903      SUBS     R9,R9,#+3
    456              inductor_value_x2 -= CRITERION_SIGNAL;
   \   0000001E   0x1EED             SUBS     R5,R5,#+3
    457              inductor_value_y1 -= CRITERION_SIGNAL;
   \   00000020   0x1EF6             SUBS     R6,R6,#+3
    458              inductor_value_y2 -= CRITERION_SIGNAL;
   \   00000022   0x1EFF             SUBS     R7,R7,#+3
    459              inductor_value_m1 -= CRITERION_SIGNAL;
   \   00000024   0xF1B8 0x0803      SUBS     R8,R8,#+3
    460              
    461              inductor_value_x1 = (int16)Limiter(inductor_value_x1, 0, 4095);
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable11_27  ;; 0x457ff000
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x468A             MOV      R10,R1
   \   00000030   0x4693             MOV      R11,R2
   \   00000032   0xFA0F 0xF989      SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
   \   00000036   0x4648             MOV      R0,R9
   \   00000038   0x.... 0x....      BL       __aeabi_i2f
   \   0000003C   0x465A             MOV      R2,R11
   \   0000003E   0x4651             MOV      R1,R10
   \   00000040   0x.... 0x....      BL       Limiter
   \   00000044   0x.... 0x....      BL       __aeabi_f2iz
   \   00000048   0x4681             MOV      R9,R0
    462              inductor_value_x2 = (int16)Limiter(inductor_value_x2, 0, 4095);
   \   0000004A   0x.... 0x....      LDR.W    R2,??DataTable11_27  ;; 0x457ff000
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x468A             MOV      R10,R1
   \   00000052   0x4693             MOV      R11,R2
   \   00000054   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \   00000056   0x0028             MOVS     R0,R5
   \   00000058   0x.... 0x....      BL       __aeabi_i2f
   \   0000005C   0x465A             MOV      R2,R11
   \   0000005E   0x4651             MOV      R1,R10
   \   00000060   0x.... 0x....      BL       Limiter
   \   00000064   0x.... 0x....      BL       __aeabi_f2iz
   \   00000068   0x0005             MOVS     R5,R0
    463              inductor_value_y1 = (int16)Limiter(inductor_value_y1, 0, 4095);
   \   0000006A   0x.... 0x....      LDR.W    R2,??DataTable11_27  ;; 0x457ff000
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x468A             MOV      R10,R1
   \   00000072   0x4693             MOV      R11,R2
   \   00000074   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   00000076   0x0030             MOVS     R0,R6
   \   00000078   0x.... 0x....      BL       __aeabi_i2f
   \   0000007C   0x465A             MOV      R2,R11
   \   0000007E   0x4651             MOV      R1,R10
   \   00000080   0x.... 0x....      BL       Limiter
   \   00000084   0x.... 0x....      BL       __aeabi_f2iz
   \   00000088   0x0006             MOVS     R6,R0
    464              inductor_value_y2 = (int16)Limiter(inductor_value_y2, 0, 4095);
   \   0000008A   0x.... 0x....      LDR.W    R2,??DataTable11_27  ;; 0x457ff000
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x468A             MOV      R10,R1
   \   00000092   0x4693             MOV      R11,R2
   \   00000094   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000096   0x0038             MOVS     R0,R7
   \   00000098   0x.... 0x....      BL       __aeabi_i2f
   \   0000009C   0x465A             MOV      R2,R11
   \   0000009E   0x4651             MOV      R1,R10
   \   000000A0   0x.... 0x....      BL       Limiter
   \   000000A4   0x.... 0x....      BL       __aeabi_f2iz
   \   000000A8   0x0007             MOVS     R7,R0
    465              inductor_value_m1 = (int16)Limiter(inductor_value_m1, 0, 4095);
   \   000000AA   0x.... 0x....      LDR.W    R2,??DataTable11_27  ;; 0x457ff000
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0x468A             MOV      R10,R1
   \   000000B2   0x4693             MOV      R11,R2
   \   000000B4   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   000000B8   0x4640             MOV      R0,R8
   \   000000BA   0x.... 0x....      BL       __aeabi_i2f
   \   000000BE   0x465A             MOV      R2,R11
   \   000000C0   0x4651             MOV      R1,R10
   \   000000C2   0x.... 0x....      BL       Limiter
   \   000000C6   0x.... 0x....      BL       __aeabi_f2iz
   \   000000CA   0x4680             MOV      R8,R0
    466              
    467              inductor_value[X_LEFT] = inductor_value_x1;
   \   000000CC   0xF8A4 0x9002      STRH     R9,[R4, #+2]
    468              inductor_value[X_RIGHT] = inductor_value_x2;
   \   000000D0   0x80E5             STRH     R5,[R4, #+6]
    469              inductor_value[T_LEFT] = inductor_value_y1;
   \   000000D2   0x8026             STRH     R6,[R4, #+0]
    470              inductor_value[T_RIGHT] = inductor_value_y2;
   \   000000D4   0x8127             STRH     R7,[R4, #+8]
    471              inductor_value[M_BACK] = inductor_value_m1;
   \   000000D6   0xF8A4 0x8004      STRH     R8,[R4, #+4]
    472            
    473          
    474          }
   \   000000DA   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    475          
    476          /*===============================================================
    477          	@brief     信号获取处理判断
    478          	@note      使用前进行一定时间滤波
    479          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    480          void Get_Signal_Value()
    481          {
   \                     Get_Signal_Value: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    482              static int16 si_cnt = 0;
    483              int16 i = 0, j = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x2100             MOVS     R1,#+0
    484              si_cnt++;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable11_28
   \   0000000A   0x8800             LDRH     R0,[R0, #+0]
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable11_28
   \   00000012   0x8008             STRH     R0,[R1, #+0]
    485              Get_Inductor_Value();
   \   00000014   0x.... 0x....      BL       Get_Inductor_Value
    486              //归一化电感   
    487              Calibrate_All_Inductor(gi_inductor_value);//8位精度
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000001C   0x.... 0x....      BL       Calibrate_All_Inductor
    488              Criterion_Signal(gi_inductor_value);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000024   0x.... 0x....      BL       Criterion_Signal
    489              if (si_cnt >= 2500)//10s
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable11_28
   \   0000002C   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000030   0xF640 0x11C4      MOVW     R1,#+2500
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xDB12             BLT.N    ??Get_Signal_Value_0
    490              {
    491                  si_cnt = 2501;
   \   00000038   0xF640 0x10C5      MOVW     R0,#+2501
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable11_28
   \   00000040   0x8008             STRH     R0,[R1, #+0]
    492                  Filter_Inductor_Value(gi_inductor_value);//8位精度滤波
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000046   0x.... 0x....      BL       Filter_Inductor_Value
    493                  if(!guc_obstacle_flag)
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable9
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD103             BNE.N    ??Get_Signal_Value_1
    494                  {
    495                      Stop_Danger_Lost_Signals(gi_inductor_value);
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000058   0x.... 0x....      BL       Stop_Danger_Lost_Signals
    496                  }
    497              }
    498              else
    499              {
    500                  for(i = 0; i < NUM_INDUCTOR; i++)
    501                  {
    502                      for(j = NUM_INDUCTOR_HISTORY-1; j >= 1; j--)
    503                      {			
    504                          si_inductor_value_history[i][j] = si_inductor_value_history[i][j-1];
    505                      }
    506                      si_inductor_value_history[i][0] = gi_inductor_value[i];
    507                  }
    508              }
    509          }
   \                     ??Get_Signal_Value_1: (+1)
   \   0000005C   0xBD01             POP      {R0,PC}          ;; return
   \                     ??Get_Signal_Value_0: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE020             B.N      ??Get_Signal_Value_2
   \                     ??Get_Signal_Value_3: (+1)
   \   00000062   0x.... 0x....      LDR.W    R2,??DataTable11_12
   \   00000066   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000068   0xEB02 0x02C0      ADD      R2,R2,R0, LSL #+3
   \   0000006C   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000006E   0x.... 0x....      LDR.W    R3,??DataTable11_12
   \   00000072   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000074   0xEB03 0x03C0      ADD      R3,R3,R0, LSL #+3
   \   00000078   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000007A   0xEB03 0x0341      ADD      R3,R3,R1, LSL #+1
   \   0000007E   0xF833 0x3C02      LDRH     R3,[R3, #-2]
   \   00000082   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   00000086   0x1E49             SUBS     R1,R1,#+1
   \                     ??Get_Signal_Value_4: (+1)
   \   00000088   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000008A   0x2901             CMP      R1,#+1
   \   0000008C   0xDAE9             BGE.N    ??Get_Signal_Value_3
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000092   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000094   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   00000098   0x.... 0x....      LDR.W    R2,??DataTable11_12
   \   0000009C   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000009E   0xF822 0x1030      STRH     R1,[R2, R0, LSL #+3]
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
   \                     ??Get_Signal_Value_2: (+1)
   \   000000A4   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000000A6   0x2805             CMP      R0,#+5
   \   000000A8   0xDAD8             BGE.N    ??Get_Signal_Value_1
   \   000000AA   0x2103             MOVS     R1,#+3
   \   000000AC   0xE7EC             B.N      ??Get_Signal_Value_4

   \                                 In section .bss, align 2
   \                     `Get_Signal_Value::si_cnt`:
   \   00000000                      DS8 2
    510          
    511          /*===============================================================
    512          	@brief     计算所有电感信号随距离变化率
    513          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    514          int16 Get_Signal_Derivative()
    515          {
   \                     Get_Signal_Derivative: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    516              static int32 sl_last_annulus_distance;//入环前车程记录
    517              static int32 sl_distance_sigma[RING_BUFF_SIZE] ;
    518              static int16 si_signal_sum[NUM_INDUCTOR][RING_BUFF_SIZE];
    519              static uint32 sul_signal_sum_buff[NUM_INDUCTOR];
    520              static uint16 sui_signal_buff_count;
    521              int32 signal_gradient_summation[NUM_INDUCTOR];
    522              static int32 sl_signal_increase_rate[NUM_INDUCTOR];
    523              
    524              int32 distance_sigma_summation = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    525              int16 i,j;
    526              
    527              //通过横电感信号变化趋势入环
    528              if(sui_signal_buff_count < 10000)//平均历史信号,使用原始信号，避免动态标定带来的影响
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable11_29
   \   0000000A   0x8809             LDRH     R1,[R1, #+0]
   \   0000000C   0xF242 0x7210      MOVW     R2,#+10000
   \   00000010   0x4291             CMP      R1,R2
   \   00000012   0xDA1C             BGE.N    ??Get_Signal_Derivative_0
    529              {  
    530                  for(i=0; i < NUM_INDUCTOR; i++)
   \   00000014   0x2400             MOVS     R4,#+0
   \   00000016   0xE010             B.N      ??Get_Signal_Derivative_1
    531                  {
    532                      sul_signal_sum_buff[i] += gi_inductor_adc[i];
   \                     ??Get_Signal_Derivative_2: (+1)
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable11_30
   \   0000001C   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000001E   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable11_10
   \   00000026   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000028   0xF932 0x2014      LDRSH    R2,[R2, R4, LSL #+1]
   \   0000002C   0x1889             ADDS     R1,R1,R2
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable11_30
   \   00000032   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000034   0xF842 0x1024      STR      R1,[R2, R4, LSL #+2]
    533                  }
   \   00000038   0x1C64             ADDS     R4,R4,#+1
   \                     ??Get_Signal_Derivative_1: (+1)
   \   0000003A   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000003C   0x2C05             CMP      R4,#+5
   \   0000003E   0xDBEB             BLT.N    ??Get_Signal_Derivative_2
    534                  sui_signal_buff_count++;
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable11_29
   \   00000044   0x8809             LDRH     R1,[R1, #+0]
   \   00000046   0x1C49             ADDS     R1,R1,#+1
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable11_29
   \   0000004C   0x8011             STRH     R1,[R2, #+0]
    535              }
    536              if(gl_car_running_distance -  sl_last_annulus_distance > 20)//等车至少跑过一段距离再检测信号强度变化
   \                     ??Get_Signal_Derivative_0: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000052   0x6809             LDR      R1,[R1, #+0]
   \   00000054   0x.... 0x....      LDR.W    R2,??DataTable11_31
   \   00000058   0x6812             LDR      R2,[R2, #+0]
   \   0000005A   0x1A89             SUBS     R1,R1,R2
   \   0000005C   0x2915             CMP      R1,#+21
   \   0000005E   0xF2C0 0x80B3      BLT.W    ??Get_Signal_Derivative_3
    537              {
    538                  for(i=0; i < RING_BUFF_SIZE - 1; i++)//缓存历史信号强度
   \   00000062   0x2400             MOVS     R4,#+0
   \   00000064   0xE022             B.N      ??Get_Signal_Derivative_4
    539                  {
    540                      for(j=0; j < NUM_INDUCTOR; j++)
    541                      {
    542                          si_signal_sum[j][i] = si_signal_sum[j][i+1];
   \                     ??Get_Signal_Derivative_5: (+1)
   \   00000066   0x.... 0x....      LDR.W    R2,??DataTable11_32
   \   0000006A   0x230A             MOVS     R3,#+10
   \   0000006C   0xFB11 0xF303      SMULBB   R3,R1,R3
   \   00000070   0x441A             ADD      R2,R2,R3
   \   00000072   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000074   0x.... 0x....      LDR.W    R3,??DataTable11_32
   \   00000078   0x250A             MOVS     R5,#+10
   \   0000007A   0xFB11 0xF505      SMULBB   R5,R1,R5
   \   0000007E   0x442B             ADD      R3,R3,R5
   \   00000080   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000082   0xEB03 0x0344      ADD      R3,R3,R4, LSL #+1
   \   00000086   0x885B             LDRH     R3,[R3, #+2]
   \   00000088   0xF822 0x3014      STRH     R3,[R2, R4, LSL #+1]
    543                      }
   \   0000008C   0x1C49             ADDS     R1,R1,#+1
   \                     ??Get_Signal_Derivative_6: (+1)
   \   0000008E   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000090   0x2905             CMP      R1,#+5
   \   00000092   0xDBE8             BLT.N    ??Get_Signal_Derivative_5
    544                      sl_distance_sigma[i] = sl_distance_sigma[i+1];
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable11_33
   \   00000098   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000009A   0xEB01 0x0184      ADD      R1,R1,R4, LSL #+2
   \   0000009E   0x6849             LDR      R1,[R1, #+4]
   \   000000A0   0x.... 0x....      LDR.W    R2,??DataTable11_33
   \   000000A4   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   000000A6   0xF842 0x1024      STR      R1,[R2, R4, LSL #+2]
   \   000000AA   0x1C64             ADDS     R4,R4,#+1
   \                     ??Get_Signal_Derivative_4: (+1)
   \   000000AC   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   000000AE   0x2C04             CMP      R4,#+4
   \   000000B0   0xDA01             BGE.N    ??Get_Signal_Derivative_7
   \   000000B2   0x2100             MOVS     R1,#+0
   \   000000B4   0xE7EB             B.N      ??Get_Signal_Derivative_6
    545                  }
    546                  for(i=0; i < NUM_INDUCTOR; i++)
   \                     ??Get_Signal_Derivative_7: (+1)
   \   000000B6   0x2400             MOVS     R4,#+0
   \   000000B8   0xE01C             B.N      ??Get_Signal_Derivative_8
    547                  {
    548                      si_signal_sum[i][RING_BUFF_SIZE-1] = sul_signal_sum_buff[i]/sui_signal_buff_count;
   \                     ??Get_Signal_Derivative_9: (+1)
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable11_30
   \   000000BE   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   000000C0   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000C4   0x.... 0x....      LDR.W    R2,??DataTable11_29
   \   000000C8   0x8812             LDRH     R2,[R2, #+0]
   \   000000CA   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000CE   0x.... 0x....      LDR.W    R2,??DataTable11_32
   \   000000D2   0x230A             MOVS     R3,#+10
   \   000000D4   0xFB14 0xF303      SMULBB   R3,R4,R3
   \   000000D8   0x441A             ADD      R2,R2,R3
   \   000000DA   0x8111             STRH     R1,[R2, #+8]
    549                      sul_signal_sum_buff[i] = 0;
   \   000000DC   0x2100             MOVS     R1,#+0
   \   000000DE   0x.... 0x....      LDR.W    R2,??DataTable11_30
   \   000000E2   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   000000E4   0xF842 0x1024      STR      R1,[R2, R4, LSL #+2]
    550                      signal_gradient_summation[i] = 0;
   \   000000E8   0x2100             MOVS     R1,#+0
   \   000000EA   0x466A             MOV      R2,SP
   \   000000EC   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   000000EE   0xF842 0x1024      STR      R1,[R2, R4, LSL #+2]
    551                  }
   \   000000F2   0x1C64             ADDS     R4,R4,#+1
   \                     ??Get_Signal_Derivative_8: (+1)
   \   000000F4   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   000000F6   0x2C05             CMP      R4,#+5
   \   000000F8   0xDBDF             BLT.N    ??Get_Signal_Derivative_9
    552                  
    553                  sui_signal_buff_count = 0;
   \   000000FA   0x2100             MOVS     R1,#+0
   \   000000FC   0x.... 0x....      LDR.W    R2,??DataTable11_29
   \   00000100   0x8011             STRH     R1,[R2, #+0]
    554                  sl_distance_sigma[RING_BUFF_SIZE-1] = (int32)(gl_car_running_distance - sl_last_annulus_distance);//乘系数，提高精度
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000106   0x6809             LDR      R1,[R1, #+0]
   \   00000108   0x.... 0x....      LDR.W    R2,??DataTable11_31
   \   0000010C   0x6812             LDR      R2,[R2, #+0]
   \   0000010E   0x1A89             SUBS     R1,R1,R2
   \   00000110   0x.... 0x....      LDR.W    R2,??DataTable11_33
   \   00000114   0x6111             STR      R1,[R2, #+16]
    555                  
    556                  for(i=0; i < RING_BUFF_SIZE / 2; i++)
   \   00000116   0x2400             MOVS     R4,#+0
   \   00000118   0xE030             B.N      ??Get_Signal_Derivative_10
    557                  {
    558                      for(j=0; j < NUM_INDUCTOR; j++)
    559                      {
    560                          signal_gradient_summation[j] += si_signal_sum[j][i + RING_BUFF_SIZE/2] - si_signal_sum[j][i];
   \                     ??Get_Signal_Derivative_11: (+1)
   \   0000011A   0x466A             MOV      R2,SP
   \   0000011C   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000011E   0xF852 0x2021      LDR      R2,[R2, R1, LSL #+2]
   \   00000122   0x.... 0x....      LDR.W    R3,??DataTable11_32
   \   00000126   0x250A             MOVS     R5,#+10
   \   00000128   0xFB11 0xF505      SMULBB   R5,R1,R5
   \   0000012C   0x442B             ADD      R3,R3,R5
   \   0000012E   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000130   0xEB03 0x0344      ADD      R3,R3,R4, LSL #+1
   \   00000134   0xF9B3 0x3004      LDRSH    R3,[R3, #+4]
   \   00000138   0xFA02 0xF283      SXTAH    R2,R2,R3
   \   0000013C   0x.... 0x....      LDR.W    R3,??DataTable11_32
   \   00000140   0x250A             MOVS     R5,#+10
   \   00000142   0xFB11 0xF505      SMULBB   R5,R1,R5
   \   00000146   0x442B             ADD      R3,R3,R5
   \   00000148   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000014A   0xF933 0x3014      LDRSH    R3,[R3, R4, LSL #+1]
   \   0000014E   0x1AD2             SUBS     R2,R2,R3
   \   00000150   0x466B             MOV      R3,SP
   \   00000152   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000154   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
    561                      }
   \   00000158   0x1C49             ADDS     R1,R1,#+1
   \                     ??Get_Signal_Derivative_12: (+1)
   \   0000015A   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000015C   0x2905             CMP      R1,#+5
   \   0000015E   0xDBDC             BLT.N    ??Get_Signal_Derivative_11
    562                      distance_sigma_summation += sl_distance_sigma[i] + sl_distance_sigma[i+RING_BUFF_SIZE/2];
   \   00000160   0x.... 0x....      LDR.W    R1,??DataTable11_33
   \   00000164   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000166   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000016A   0x.... 0x....      LDR.W    R2,??DataTable11_33
   \   0000016E   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000170   0xEB02 0x0284      ADD      R2,R2,R4, LSL #+2
   \   00000174   0x6892             LDR      R2,[R2, #+8]
   \   00000176   0x1851             ADDS     R1,R2,R1
   \   00000178   0x1808             ADDS     R0,R1,R0
   \   0000017A   0x1C64             ADDS     R4,R4,#+1
   \                     ??Get_Signal_Derivative_10: (+1)
   \   0000017C   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000017E   0x2C02             CMP      R4,#+2
   \   00000180   0xDA01             BGE.N    ??Get_Signal_Derivative_13
   \   00000182   0x2100             MOVS     R1,#+0
   \   00000184   0xE7E9             B.N      ??Get_Signal_Derivative_12
    563                  }
    564                  for(i=0; i < NUM_INDUCTOR; i++)
   \                     ??Get_Signal_Derivative_13: (+1)
   \   00000186   0x2400             MOVS     R4,#+0
   \   00000188   0xE016             B.N      ??Get_Signal_Derivative_14
    565                  {
    566                      sl_signal_increase_rate[i] = (100*1500/gi_inductor_calibrate_value[CALI_MID]) * signal_gradient_summation[i]/ //归一化
    567                                  ((RING_BUFF_SIZE/2)*(RING_BUFF_SIZE/2) * distance_sigma_summation+1); //防止除零
   \                     ??Get_Signal_Derivative_15: (+1)
   \   0000018A   0x.... 0x....      LDR.W    R1,??DataTable11_34  ;; 0x249f0
   \   0000018E   0x.... 0x....      LDR.W    R2,??DataTable11_35
   \   00000192   0xF9B2 0x2002      LDRSH    R2,[R2, #+2]
   \   00000196   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000019A   0x466A             MOV      R2,SP
   \   0000019C   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000019E   0xF852 0x2024      LDR      R2,[R2, R4, LSL #+2]
   \   000001A2   0x4351             MULS     R1,R2,R1
   \   000001A4   0x0082             LSLS     R2,R0,#+2
   \   000001A6   0x1C52             ADDS     R2,R2,#+1
   \   000001A8   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   000001AC   0x.... 0x....      LDR.W    R2,??DataTable11_36
   \   000001B0   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   000001B2   0xF842 0x1024      STR      R1,[R2, R4, LSL #+2]
    568                  }
   \   000001B6   0x1C64             ADDS     R4,R4,#+1
   \                     ??Get_Signal_Derivative_14: (+1)
   \   000001B8   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   000001BA   0x2C05             CMP      R4,#+5
   \   000001BC   0xDBE5             BLT.N    ??Get_Signal_Derivative_15
    569                  
    570                  sl_last_annulus_distance = (int32)gl_car_running_distance;        
   \   000001BE   0x....             LDR.N    R0,??DataTable10
   \   000001C0   0x6800             LDR      R0,[R0, #+0]
   \   000001C2   0x.... 0x....      LDR.W    R1,??DataTable11_31
   \   000001C6   0x6008             STR      R0,[R1, #+0]
    571              }
    572              
    573              if(gl_car_running_distance < 20)
   \                     ??Get_Signal_Derivative_3: (+1)
   \   000001C8   0x....             LDR.N    R0,??DataTable10
   \   000001CA   0x6800             LDR      R0,[R0, #+0]
   \   000001CC   0x2814             CMP      R0,#+20
   \   000001CE   0xDA0B             BGE.N    ??Get_Signal_Derivative_16
    574              {
    575                  for(i=0; i < NUM_INDUCTOR; i++)
   \   000001D0   0x2400             MOVS     R4,#+0
   \   000001D2   0xE006             B.N      ??Get_Signal_Derivative_17
    576                  {
    577                      sl_signal_increase_rate[i] = 0; 
   \                     ??Get_Signal_Derivative_18: (+1)
   \   000001D4   0x2000             MOVS     R0,#+0
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable11_36
   \   000001DA   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   000001DC   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
    578                  }
   \   000001E0   0x1C64             ADDS     R4,R4,#+1
   \                     ??Get_Signal_Derivative_17: (+1)
   \   000001E2   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   000001E4   0x2C05             CMP      R4,#+5
   \   000001E6   0xDBF5             BLT.N    ??Get_Signal_Derivative_18
    579              }
    580              
    581              for(i=0; i < NUM_INDUCTOR; i++)
   \                     ??Get_Signal_Derivative_16: (+1)
   \   000001E8   0x2400             MOVS     R4,#+0
   \   000001EA   0xE01F             B.N      ??Get_Signal_Derivative_19
    582              {
    583                  sl_signal_increase_rate[i] = (int32)Limiter(sl_signal_increase_rate[i],-10000,10000);  
   \                     ??Get_Signal_Derivative_20: (+1)
   \   000001EC   0x.... 0x....      LDR.W    R2,??DataTable11_37  ;; 0x461c4000
   \   000001F0   0x.... 0x....      LDR.W    R1,??DataTable11_38  ;; 0xc61c4000
   \   000001F4   0x000D             MOVS     R5,R1
   \   000001F6   0x0016             MOVS     R6,R2
   \   000001F8   0x.... 0x....      LDR.W    R0,??DataTable11_36
   \   000001FC   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   000001FE   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000202   0x.... 0x....      BL       __aeabi_i2f
   \   00000206   0x0032             MOVS     R2,R6
   \   00000208   0x0029             MOVS     R1,R5
   \   0000020A   0x.... 0x....      BL       Limiter
   \   0000020E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000212   0x....             LDR.N    R1,??DataTable11_36
   \   00000214   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000216   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
    584                  gi_signal_gradient[i] = sl_signal_increase_rate[i];
   \   0000021A   0x....             LDR.N    R0,??DataTable11_36
   \   0000021C   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000021E   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000222   0x....             LDR.N    R1,??DataTable11_1
   \   00000224   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000226   0xF821 0x0014      STRH     R0,[R1, R4, LSL #+1]
    585              }
   \   0000022A   0x1C64             ADDS     R4,R4,#+1
   \                     ??Get_Signal_Derivative_19: (+1)
   \   0000022C   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000022E   0x2C05             CMP      R4,#+5
   \   00000230   0xDBDC             BLT.N    ??Get_Signal_Derivative_20
    586              return 0;
   \   00000232   0x2000             MOVS     R0,#+0
   \   00000234   0xB006             ADD      SP,SP,#+24
   \   00000236   0xBD70             POP      {R4-R6,PC}       ;; return
    587          }

   \                                 In section .bss, align 4
   \                     `Get_Signal_Derivative::sl_last_annulus_distance`:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     `Get_Signal_Derivative::sl_distance_sigma`:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
   \                     `Get_Signal_Derivative::si_signal_sum`:
   \   00000000                      DS8 52

   \                                 In section .bss, align 4
   \                     `Get_Signal_Derivative::sul_signal_sum_buff`:
   \   00000000                      DS8 20

   \                                 In section .bss, align 2
   \                     `Get_Signal_Derivative::sui_signal_buff_count`:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \                     `Get_Signal_Derivative::sl_signal_increase_rate`:
   \   00000000                      DS8 20
    588          
    589          /*===============================================================
    590          	@brief     获取车身姿态
    591          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    592          void Get_Position()
    593          {
   \                     Get_Position: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    594              static int16 si_roll_dps_buff[POS_BUFF_SIZE];
    595              static int16 si_pitch_dps_buff[POS_BUFF_SIZE];
    596              static uint8 suc_buff_sequence;
    597          //    static uint8 suc_test_yaw_flag = 0;//测试偏航角标志位，发车后清零
    598              
    599              uint32 roll_square = 0, pitch_square = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2500             MOVS     R5,#+0
    600              int32 roll_summation = 0, pitch_summation = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x2700             MOVS     R7,#+0
    601              int i;
    602              
    603              if(guc_gyro_zero_flag)
   \   0000000C   0x....             LDR.N    R0,??DataTable11_39
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xF000 0x80BD      BEQ.W    ??Get_Position_0
    604              {
    605                  //采集数据
    606              //    Get_Acc_X();
    607              //    Get_Acc_Y();
    608              //    Get_Acc_Z();
    609                  Get_Gyro_X();
   \   00000016   0x.... 0x....      BL       Get_Gyro_X
    610                  Get_Gyro_Y();
   \   0000001A   0x.... 0x....      BL       Get_Gyro_Y
    611                  Get_Gyro_Z();
   \   0000001E   0x.... 0x....      BL       Get_Gyro_Z
    612                  
    613                  Get_Annulus_Angle();
   \   00000022   0x.... 0x....      BL       Get_Annulus_Angle
    614                  Get_Slope_Angle();
   \   00000026   0x.... 0x....      BL       Get_Slope_Angle
    615                  Get_Obstacle_Angle();
   \   0000002A   0x.... 0x....      BL       Get_Obstacle_Angle
    616          
    617                  gf_roll_angle += mpu_gyro_x * (PIT_1_PERIOD_S);
   \   0000002E   0x....             LDR.N    R0,??DataTable11_40
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x.... 0x....      BL       __aeabi_f2d
   \   00000036   0x4680             MOV      R8,R0
   \   00000038   0x4689             MOV      R9,R1
   \   0000003A   0x....             LDR.N    R0,??DataTable11_41
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x.... 0x....      BL       __aeabi_f2d
   \   00000042   0x....             LDR.N    R2,??DataTable11_42  ;; 0xd2f1a9fc
   \   00000044   0x....             LDR.N    R3,??DataTable11_43  ;; 0x3f70624d
   \   00000046   0x.... 0x....      BL       __aeabi_dmul
   \   0000004A   0x4642             MOV      R2,R8
   \   0000004C   0x464B             MOV      R3,R9
   \   0000004E   0x.... 0x....      BL       __aeabi_dadd
   \   00000052   0x.... 0x....      BL       __aeabi_d2f
   \   00000056   0x....             LDR.N    R1,??DataTable11_40
   \   00000058   0x6008             STR      R0,[R1, #+0]
    618                  gf_pitch_angle += mpu_gyro_y * (PIT_1_PERIOD_S);
   \   0000005A   0x....             LDR.N    R0,??DataTable11_44
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x.... 0x....      BL       __aeabi_f2d
   \   00000062   0x4680             MOV      R8,R0
   \   00000064   0x4689             MOV      R9,R1
   \   00000066   0x....             LDR.N    R0,??DataTable11_45
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x.... 0x....      BL       __aeabi_f2d
   \   0000006E   0x....             LDR.N    R2,??DataTable11_42  ;; 0xd2f1a9fc
   \   00000070   0x....             LDR.N    R3,??DataTable11_43  ;; 0x3f70624d
   \   00000072   0x.... 0x....      BL       __aeabi_dmul
   \   00000076   0x4642             MOV      R2,R8
   \   00000078   0x464B             MOV      R3,R9
   \   0000007A   0x.... 0x....      BL       __aeabi_dadd
   \   0000007E   0x.... 0x....      BL       __aeabi_d2f
   \   00000082   0x....             LDR.N    R1,??DataTable11_44
   \   00000084   0x6008             STR      R0,[R1, #+0]
    619                  gf_yaw_angle += mpu_gyro_z * (PIT_1_PERIOD_S);
   \   00000086   0x....             LDR.N    R0,??DataTable11_46
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x.... 0x....      BL       __aeabi_f2d
   \   0000008E   0x4680             MOV      R8,R0
   \   00000090   0x4689             MOV      R9,R1
   \   00000092   0x....             LDR.N    R0,??DataTable11_47
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x.... 0x....      BL       __aeabi_f2d
   \   0000009A   0x....             LDR.N    R2,??DataTable11_42  ;; 0xd2f1a9fc
   \   0000009C   0x....             LDR.N    R3,??DataTable11_43  ;; 0x3f70624d
   \   0000009E   0x.... 0x....      BL       __aeabi_dmul
   \   000000A2   0x4642             MOV      R2,R8
   \   000000A4   0x464B             MOV      R3,R9
   \   000000A6   0x.... 0x....      BL       __aeabi_dadd
   \   000000AA   0x.... 0x....      BL       __aeabi_d2f
   \   000000AE   0x....             LDR.N    R1,??DataTable11_46
   \   000000B0   0x6008             STR      R0,[R1, #+0]
    620          
    621                  gf_roll_velocity = mpu_gyro_x;
   \   000000B2   0x....             LDR.N    R0,??DataTable11_41
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x....             LDR.N    R1,??DataTable11_48
   \   000000B8   0x6008             STR      R0,[R1, #+0]
    622                  gf_pitch_velocity = mpu_gyro_y;
   \   000000BA   0x....             LDR.N    R0,??DataTable11_45
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x....             LDR.N    R1,??DataTable11_49
   \   000000C0   0x6008             STR      R0,[R1, #+0]
    623                  gf_yaw_velocity = mpu_gyro_z;
   \   000000C2   0x....             LDR.N    R0,??DataTable11_47
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x....             LDR.N    R1,??DataTable11_50
   \   000000C8   0x6008             STR      R0,[R1, #+0]
    624                  
    625                  //姿态方差计算
    626                  si_roll_dps_buff[suc_buff_sequence] = (int16)(gf_roll_velocity * 10);
   \   000000CA   0x....             LDR.N    R0,??DataTable11_48
   \   000000CC   0x6801             LDR      R1,[R0, #+0]
   \   000000CE   0x....             LDR.N    R0,??DataTable11_51  ;; 0x41200000
   \   000000D0   0x.... 0x....      BL       __aeabi_fmul
   \   000000D4   0x.... 0x....      BL       __aeabi_f2iz
   \   000000D8   0x....             LDR.N    R1,??DataTable11_52
   \   000000DA   0x....             LDR.N    R2,??DataTable11_53
   \   000000DC   0x7812             LDRB     R2,[R2, #+0]
   \   000000DE   0xF821 0x0012      STRH     R0,[R1, R2, LSL #+1]
    627                  si_pitch_dps_buff[suc_buff_sequence] = (int16)(gf_pitch_velocity * 10);
   \   000000E2   0x....             LDR.N    R0,??DataTable11_49
   \   000000E4   0x6801             LDR      R1,[R0, #+0]
   \   000000E6   0x....             LDR.N    R0,??DataTable11_51  ;; 0x41200000
   \   000000E8   0x.... 0x....      BL       __aeabi_fmul
   \   000000EC   0x.... 0x....      BL       __aeabi_f2iz
   \   000000F0   0x....             LDR.N    R1,??DataTable11_54
   \   000000F2   0x....             LDR.N    R2,??DataTable11_53
   \   000000F4   0x7812             LDRB     R2,[R2, #+0]
   \   000000F6   0xF821 0x0012      STRH     R0,[R1, R2, LSL #+1]
    628                  suc_buff_sequence++;
   \   000000FA   0x....             LDR.N    R0,??DataTable11_53
   \   000000FC   0x7800             LDRB     R0,[R0, #+0]
   \   000000FE   0x1C40             ADDS     R0,R0,#+1
   \   00000100   0x....             LDR.N    R1,??DataTable11_53
   \   00000102   0x7008             STRB     R0,[R1, #+0]
    629                  
    630                  if(suc_buff_sequence >= POS_BUFF_SIZE)
   \   00000104   0x....             LDR.N    R0,??DataTable11_53
   \   00000106   0x7800             LDRB     R0,[R0, #+0]
   \   00000108   0x2819             CMP      R0,#+25
   \   0000010A   0xDB02             BLT.N    ??Get_Position_1
    631                  {
    632                      suc_buff_sequence = 0;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x....             LDR.N    R1,??DataTable11_53
   \   00000110   0x7008             STRB     R0,[R1, #+0]
    633                  }
    634                  for(i=0; i < POS_BUFF_SIZE; i++)
   \                     ??Get_Position_1: (+1)
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xE020             B.N      ??Get_Position_2
    635                  {
    636                      roll_square += (int32)(si_roll_dps_buff[i] * si_roll_dps_buff[i]/POS_BUFF_SIZE);
   \                     ??Get_Position_3: (+1)
   \   00000116   0x....             LDR.N    R1,??DataTable11_52
   \   00000118   0xF931 0x1010      LDRSH    R1,[R1, R0, LSL #+1]
   \   0000011C   0x....             LDR.N    R2,??DataTable11_52
   \   0000011E   0xF932 0x2010      LDRSH    R2,[R2, R0, LSL #+1]
   \   00000122   0xFB11 0xF102      SMULBB   R1,R1,R2
   \   00000126   0x2219             MOVS     R2,#+25
   \   00000128   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000012C   0x190C             ADDS     R4,R1,R4
    637                      roll_summation += si_roll_dps_buff[i];
   \   0000012E   0x....             LDR.N    R1,??DataTable11_52
   \   00000130   0xF931 0x1010      LDRSH    R1,[R1, R0, LSL #+1]
   \   00000134   0x1876             ADDS     R6,R6,R1
    638                      pitch_square += (int32)(si_pitch_dps_buff[i] * si_pitch_dps_buff[i]/POS_BUFF_SIZE);
   \   00000136   0x....             LDR.N    R1,??DataTable11_54
   \   00000138   0xF931 0x1010      LDRSH    R1,[R1, R0, LSL #+1]
   \   0000013C   0x....             LDR.N    R2,??DataTable11_54
   \   0000013E   0xF932 0x2010      LDRSH    R2,[R2, R0, LSL #+1]
   \   00000142   0xFB11 0xF102      SMULBB   R1,R1,R2
   \   00000146   0x2219             MOVS     R2,#+25
   \   00000148   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000014C   0x194D             ADDS     R5,R1,R5
    639                      pitch_summation += si_pitch_dps_buff[i];
   \   0000014E   0x....             LDR.N    R1,??DataTable11_54
   \   00000150   0xF931 0x1010      LDRSH    R1,[R1, R0, LSL #+1]
   \   00000154   0x187F             ADDS     R7,R7,R1
    640                  }
   \   00000156   0x1C40             ADDS     R0,R0,#+1
   \                     ??Get_Position_2: (+1)
   \   00000158   0x2819             CMP      R0,#+25
   \   0000015A   0xDBDC             BLT.N    ??Get_Position_3
    641                  roll_square = roll_square - (roll_summation / POS_BUFF_SIZE) * (roll_summation / POS_BUFF_SIZE);
   \   0000015C   0x2019             MOVS     R0,#+25
   \   0000015E   0xFB96 0xF0F0      SDIV     R0,R6,R0
   \   00000162   0x2119             MOVS     R1,#+25
   \   00000164   0xFB96 0xF1F1      SDIV     R1,R6,R1
   \   00000168   0xFB01 0x4410      MLS      R4,R1,R0,R4
    642                  pitch_square = pitch_square - (pitch_summation / POS_BUFF_SIZE) * (pitch_summation / POS_BUFF_SIZE);
   \   0000016C   0x2019             MOVS     R0,#+25
   \   0000016E   0xFB97 0xF0F0      SDIV     R0,R7,R0
   \   00000172   0x2119             MOVS     R1,#+25
   \   00000174   0xFB97 0xF1F1      SDIV     R1,R7,R1
   \   00000178   0xFB01 0x5510      MLS      R5,R1,R0,R5
    643                  gi_pitch_variance = i_sqrt(pitch_square);
   \   0000017C   0x0028             MOVS     R0,R5
   \   0000017E   0x.... 0x....      BL       i_sqrt
   \   00000182   0x....             LDR.N    R1,??DataTable11_55
   \   00000184   0x8008             STRH     R0,[R1, #+0]
    644                  gi_roll_variance = i_sqrt(roll_square);
   \   00000186   0x0020             MOVS     R0,R4
   \   00000188   0x.... 0x....      BL       i_sqrt
   \   0000018C   0x....             LDR.N    R1,??DataTable11_56
   \   0000018E   0x8008             STRH     R0,[R1, #+0]
    645              }
    646          
    647          }
   \                     ??Get_Position_0: (+1)
   \   00000190   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .bss, align 4
   \                     `Get_Position::si_roll_dps_buff`:
   \   00000000                      DS8 52

   \                                 In section .bss, align 4
   \                     `Get_Position::si_pitch_dps_buff`:
   \   00000000                      DS8 52

   \                                 In section .bss, align 1
   \                     `Get_Position::suc_buff_sequence`:
   \   00000000                      DS8 1
    648          
    649          /*===============================================================
    650          	@brief     积分得到车模偏航角度，处理环岛判断是否完成一圈
    651          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    652          void Get_Annulus_Angle()
    653          { 
   \                     Get_Annulus_Angle: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    654             if(guc_annulus_yaw_flag)
   \   00000002   0x....             LDR.N    R0,??DataTable11_57
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD016             BEQ.N    ??Get_Annulus_Angle_0
    655             {
    656                 gf_annulus_angle += gf_yaw_velocity * (PIT_1_PERIOD_S);
   \   0000000A   0x....             LDR.N    R0,??DataTable11_58
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       __aeabi_f2d
   \   00000012   0x0004             MOVS     R4,R0
   \   00000014   0x000D             MOVS     R5,R1
   \   00000016   0x....             LDR.N    R0,??DataTable11_50
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x.... 0x....      BL       __aeabi_f2d
   \   0000001E   0x....             LDR.N    R2,??DataTable11_42  ;; 0xd2f1a9fc
   \   00000020   0x....             LDR.N    R3,??DataTable11_43  ;; 0x3f70624d
   \   00000022   0x.... 0x....      BL       __aeabi_dmul
   \   00000026   0x0022             MOVS     R2,R4
   \   00000028   0x002B             MOVS     R3,R5
   \   0000002A   0x.... 0x....      BL       __aeabi_dadd
   \   0000002E   0x.... 0x....      BL       __aeabi_d2f
   \   00000032   0x....             LDR.N    R1,??DataTable11_58
   \   00000034   0x6008             STR      R0,[R1, #+0]
   \   00000036   0xE002             B.N      ??Get_Annulus_Angle_1
    657             }
    658             else
    659             {
    660                 gf_annulus_angle = 0;
   \                     ??Get_Annulus_Angle_0: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x....             LDR.N    R1,??DataTable11_58
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    661             }
    662          }
   \                     ??Get_Annulus_Angle_1: (+1)
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    663          
    664          /*===============================================================
    665          	@brief     积分得到车模俯仰角度处理坡道
    666          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    667          void Get_Slope_Angle()
    668          { 
   \                     Get_Slope_Angle: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    669             if(guc_slope_pitch_flag)
   \   00000002   0x....             LDR.N    R0,??DataTable11_59
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD016             BEQ.N    ??Get_Slope_Angle_0
    670             {
    671                 gf_slope_picth_angle += gf_pitch_velocity * (PIT_1_PERIOD_S);
   \   0000000A   0x....             LDR.N    R0,??DataTable11_60
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       __aeabi_f2d
   \   00000012   0x0004             MOVS     R4,R0
   \   00000014   0x000D             MOVS     R5,R1
   \   00000016   0x....             LDR.N    R0,??DataTable11_49
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x.... 0x....      BL       __aeabi_f2d
   \   0000001E   0x....             LDR.N    R2,??DataTable11_42  ;; 0xd2f1a9fc
   \   00000020   0x....             LDR.N    R3,??DataTable11_43  ;; 0x3f70624d
   \   00000022   0x.... 0x....      BL       __aeabi_dmul
   \   00000026   0x0022             MOVS     R2,R4
   \   00000028   0x002B             MOVS     R3,R5
   \   0000002A   0x.... 0x....      BL       __aeabi_dadd
   \   0000002E   0x.... 0x....      BL       __aeabi_d2f
   \   00000032   0x....             LDR.N    R1,??DataTable11_60
   \   00000034   0x6008             STR      R0,[R1, #+0]
   \   00000036   0xE002             B.N      ??Get_Slope_Angle_1
    672             }
    673             else
    674             {
    675                 gf_slope_picth_angle = 0;
   \                     ??Get_Slope_Angle_0: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x....             LDR.N    R1,??DataTable11_60
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    676             }
    677          }
   \                     ??Get_Slope_Angle_1: (+1)
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    678          
    679          /*===============================================================
    680          	@brief     积分得到车模偏航角度，避障使用
    681          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    682          void Get_Obstacle_Angle()
    683          { 
   \                     Get_Obstacle_Angle: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    684             if(guc_obstacle_flag)
   \   00000002   0x....             LDR.N    R0,??DataTable11_61
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD016             BEQ.N    ??Get_Obstacle_Angle_0
    685             {
    686                 gf_camber_angle += gf_yaw_velocity * (PIT_1_PERIOD_S);
   \   0000000A   0x....             LDR.N    R0,??DataTable11_62
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       __aeabi_f2d
   \   00000012   0x0004             MOVS     R4,R0
   \   00000014   0x000D             MOVS     R5,R1
   \   00000016   0x....             LDR.N    R0,??DataTable11_50
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x.... 0x....      BL       __aeabi_f2d
   \   0000001E   0x....             LDR.N    R2,??DataTable11_42  ;; 0xd2f1a9fc
   \   00000020   0x....             LDR.N    R3,??DataTable11_43  ;; 0x3f70624d
   \   00000022   0x.... 0x....      BL       __aeabi_dmul
   \   00000026   0x0022             MOVS     R2,R4
   \   00000028   0x002B             MOVS     R3,R5
   \   0000002A   0x.... 0x....      BL       __aeabi_dadd
   \   0000002E   0x.... 0x....      BL       __aeabi_d2f
   \   00000032   0x....             LDR.N    R1,??DataTable11_62
   \   00000034   0x6008             STR      R0,[R1, #+0]
   \   00000036   0xE002             B.N      ??Get_Obstacle_Angle_1
    687             }
    688             else
    689             {
    690                 gf_camber_angle = 0;
   \                     ??Get_Obstacle_Angle_0: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x....             LDR.N    R1,??DataTable11_62
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    691             }
    692          }
   \                     ??Get_Obstacle_Angle_1: (+1)
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     gl_speed_straight

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     gi_x_signal_gradient

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     gi_m_signal_gradient

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     gl_car_speed_set

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     gi_y_signal_gradient

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     guc_distinction_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     guc_lost_signal_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     guc_obstacle_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     guc_slope_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     guc_annulus_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     guc_obstacle_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     guc_crucifix_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     gl_car_running_distance

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     guc_straight_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     gl_voltage_input

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     gi_inductor_value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     gi_signal_gradient

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     guc_car_run_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     guc_reed_state_value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     gul_time_start

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x000186A1         DC32     0x186a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     gl_car_destination_distance

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     guc_destination_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     `Signal_Control::stopline_distance`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     gl_car_stopline_distance

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x........         DC32     gi_inductor_adc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x........         DC32     `Stop_Danger_Lost_Signals::danger_count`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x........         DC32     si_inductor_value_history

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x........         DC32     `Filter_Inductor_Value::last_inductor_value`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x........         DC32     `Filter_Inductor_Value::inductor_value_jump_times`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \   00000000   0x42C80000         DC32     0x42c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \   00000000   0x43480000         DC32     0x43480000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \   00000000   0x........         DC32     guc_direction_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_18:
   \   00000000   0x41200001         DC32     0x41200001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_19:
   \   00000000   0xC1200000         DC32     0xc1200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_20:
   \   00000000   0x........         DC32     gui_t_weight

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_21:
   \   00000000   0x........         DC32     gi_inductor_t_offset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_22:
   \   00000000   0x........         DC32     gui_x_weight

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_23:
   \   00000000   0x........         DC32     gi_inductor_x_offset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_24:
   \   00000000   0x........         DC32     gui_t_div_weight

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_25:
   \   00000000   0x........         DC32     gi_inductor_t_difference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_26:
   \   00000000   0x........         DC32     gl_car_error

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_27:
   \   00000000   0x457FF000         DC32     0x457ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_28:
   \   00000000   0x........         DC32     `Get_Signal_Value::si_cnt`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_29:
   \   00000000   0x........         DC32     `Get_Signal_Derivative::sui_signal_buff_count`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_30:
   \   00000000   0x........         DC32     `Get_Signal_Derivative::sul_signal_sum_buff`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_31:
   \   00000000   0x........         DC32     `Get_Signal_Derivative::sl_last_annulus_distance`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_32:
   \   00000000   0x........         DC32     `Get_Signal_Derivative::si_signal_sum`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_33:
   \   00000000   0x........         DC32     `Get_Signal_Derivative::sl_distance_sigma`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_34:
   \   00000000   0x000249F0         DC32     0x249f0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_35:
   \   00000000   0x........         DC32     gi_inductor_calibrate_value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_36:
   \   00000000   0x........         DC32     `Get_Signal_Derivative::sl_signal_increase_rate`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_37:
   \   00000000   0x461C4000         DC32     0x461c4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_38:
   \   00000000   0xC61C4000         DC32     0xc61c4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_39:
   \   00000000   0x........         DC32     guc_gyro_zero_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_40:
   \   00000000   0x........         DC32     gf_roll_angle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_41:
   \   00000000   0x........         DC32     mpu_gyro_x

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_42:
   \   00000000   0xD2F1A9FC         DC32     0xd2f1a9fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_43:
   \   00000000   0x3F70624D         DC32     0x3f70624d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_44:
   \   00000000   0x........         DC32     gf_pitch_angle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_45:
   \   00000000   0x........         DC32     mpu_gyro_y

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_46:
   \   00000000   0x........         DC32     gf_yaw_angle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_47:
   \   00000000   0x........         DC32     mpu_gyro_z

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_48:
   \   00000000   0x........         DC32     gf_roll_velocity

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_49:
   \   00000000   0x........         DC32     gf_pitch_velocity

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_50:
   \   00000000   0x........         DC32     gf_yaw_velocity

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_51:
   \   00000000   0x41200000         DC32     0x41200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_52:
   \   00000000   0x........         DC32     `Get_Position::si_roll_dps_buff`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_53:
   \   00000000   0x........         DC32     `Get_Position::suc_buff_sequence`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_54:
   \   00000000   0x........         DC32     `Get_Position::si_pitch_dps_buff`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_55:
   \   00000000   0x........         DC32     gi_pitch_variance

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_56:
   \   00000000   0x........         DC32     gi_roll_variance

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_57:
   \   00000000   0x........         DC32     guc_annulus_yaw_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_58:
   \   00000000   0x........         DC32     gf_annulus_angle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_59:
   \   00000000   0x........         DC32     guc_slope_pitch_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_60:
   \   00000000   0x........         DC32     gf_slope_picth_angle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_61:
   \   00000000   0x........         DC32     guc_obstacle_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_62:
   \   00000000   0x........         DC32     gf_camber_angle

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   Criterion_Signal
        40   -> Limiter
        40   -> __aeabi_f2iz
        40   -> __aeabi_i2f
      16   Filter_Inductor_Value
        16   -> least_squares_value
      16   Get_Annulus_Angle
        16   -> __aeabi_d2f
        16   -> __aeabi_dadd
        16   -> __aeabi_dmul
        16   -> __aeabi_f2d
      16   Get_Inductor_Value
        16   -> Inductor_All_Get
      16   Get_Obstacle_Angle
        16   -> __aeabi_d2f
        16   -> __aeabi_dadd
        16   -> __aeabi_dmul
        16   -> __aeabi_f2d
      32   Get_Position
        32   -> Get_Annulus_Angle
        32   -> Get_Gyro_X
        32   -> Get_Gyro_Y
        32   -> Get_Gyro_Z
        32   -> Get_Obstacle_Angle
        32   -> Get_Slope_Angle
        32   -> __aeabi_d2f
        32   -> __aeabi_dadd
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_f2iz
        32   -> __aeabi_fmul
        32   -> i_sqrt
      32   Get_Sensor_Offset
        32   -> __aeabi_f2iz
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_i2f
        32   -> __aeabi_ui2f
        32 __aeabi_cfcmple
        32 __aeabi_cfrcmple
      40   Get_Signal_Derivative
        40   -> Limiter
        40   -> __aeabi_f2iz
        40   -> __aeabi_i2f
       8   Get_Signal_Value
         8   -> Calibrate_All_Inductor
         8   -> Criterion_Signal
         8   -> Filter_Inductor_Value
         8   -> Get_Inductor_Value
         8   -> Stop_Danger_Lost_Signals
      16   Get_Slope_Angle
        16   -> __aeabi_d2f
        16   -> __aeabi_dadd
        16   -> __aeabi_dmul
        16   -> __aeabi_f2d
       8   Signal_Control
         8   -> Annulus_Process
         8   -> Beep_Off
         8   -> Beep_On
         8   -> Calibrate_Once
         8   -> Distinguish_Obstacle
         8   -> End_Calibration
         8   -> Get_Sensor_Offset
         8   -> Get_Signal_Derivative
         8   -> Get_Signal_Value
         8   -> Judge_Annulus
         8   -> Judge_Crucifix
         8   -> Judge_Lost_Signal
         8   -> Judge_Slope
         8   -> Jugde_Obstacle
         8   -> Obstacle_Process
         8   -> Slope_Process
       0   Stop_Danger_Lost_Signals


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_22
       4  ??DataTable11_23
       4  ??DataTable11_24
       4  ??DataTable11_25
       4  ??DataTable11_26
       4  ??DataTable11_27
       4  ??DataTable11_28
       4  ??DataTable11_29
       4  ??DataTable11_3
       4  ??DataTable11_30
       4  ??DataTable11_31
       4  ??DataTable11_32
       4  ??DataTable11_33
       4  ??DataTable11_34
       4  ??DataTable11_35
       4  ??DataTable11_36
       4  ??DataTable11_37
       4  ??DataTable11_38
       4  ??DataTable11_39
       4  ??DataTable11_4
       4  ??DataTable11_40
       4  ??DataTable11_41
       4  ??DataTable11_42
       4  ??DataTable11_43
       4  ??DataTable11_44
       4  ??DataTable11_45
       4  ??DataTable11_46
       4  ??DataTable11_47
       4  ??DataTable11_48
       4  ??DataTable11_49
       4  ??DataTable11_5
       4  ??DataTable11_50
       4  ??DataTable11_51
       4  ??DataTable11_52
       4  ??DataTable11_53
       4  ??DataTable11_54
       4  ??DataTable11_55
       4  ??DataTable11_56
       4  ??DataTable11_57
       4  ??DataTable11_58
       4  ??DataTable11_59
       4  ??DataTable11_6
       4  ??DataTable11_60
       4  ??DataTable11_61
       4  ??DataTable11_62
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
     222  Criterion_Signal
     476  Filter_Inductor_Value
      64  Get_Annulus_Angle
     110  Get_Inductor_Value
      64  Get_Obstacle_Angle
     404  Get_Position
     338  Get_Sensor_Offset
     568  Get_Signal_Derivative
     174  Get_Signal_Value
      64  Get_Slope_Angle
     678  Signal_Control
     100  Stop_Danger_Lost_Signals
       4  danger_count
      20  inductor_value_jump_times
      12  last_inductor_value
       2  si_cnt
      40  si_inductor_value_history
      52  si_pitch_dps_buff
      52  si_roll_dps_buff
      52  si_signal_sum
      20  sl_distance_sigma
       4  sl_last_annulus_distance
      20  sl_signal_increase_rate
       4  stopline_distance
       1  suc_buff_sequence
       2  sui_signal_buff_count
      20  sul_signal_sum_buff

 
   305 bytes in section .bss
 3 574 bytes in section .text
 
 3 574 bytes of CODE memory
   305 bytes of DATA memory

Errors: none
Warnings: none
