###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       08/Jul/2019  02:42:59
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\app\drivers\src\i2c.c
#    Command line =  
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\app\drivers\src\i2c.c
#        -D LPLD_K60 -lCN
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\FLASH\List
#        -lB
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\FLASH\List
#        -o
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\CPU\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\common\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\LPLD\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\LPLD\HW\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\FatFs\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\FatFs\option\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\USB\common\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\USB\driver\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\USB\descriptor\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\USB\class\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\control\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\debug\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\device\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\signal\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\system\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\control\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\debug\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\device\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\signal\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\system\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\drivers\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\drivers\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\charge\inc\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\app\charge\src\
#        -I
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\..\..\..\lib\LPLD\FUNC\
#        -Ol -I "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\FLASH\List\i2c.lst
#    Object file  =  
#        D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\iar\FLASH\Obj\i2c.o
#
###############################################################################

D:\Freescale\无线节能14th\wireless_energy_saving_14th\14th_wireless_energy_saving_NXP\14th_wireless_energy_saving\project\14th_wireless_energy_saving\app\drivers\src\i2c.c
      1          /*=============================================
      2              @file         i2c.c
      3              @brief        模拟IIC
      4              @programmer   Beyond Hsueh
      5          =============================================*/
      6          
      7          #include "i2c.h"
      8          
      9          /*===============================================================
     10                  @note      北国风光，千里冰封，万里雪飘。
     11                             望长城内外,惟余莽莽；
     12                             大河上下，顿失滔滔。
     13                             山舞银蛇，原驰蜡象，欲与天公试比高。
     14                             须晴日，看红装素裹，分外妖娆。
     15                             江山如此多娇，引无数英雄竞折腰。
     16                             惜秦皇汉武，略输文采；
     17                             唐宗宋祖，稍逊风骚。
     18                             一代天骄，成吉思汗，只识弯弓射大雕。
     19                             俱往矣，数风流人物，还看今朝。
     20          ==================================================================*/
     21          
     22          /*===============================================================
     23          	@brief     初始化模拟IIC
     24                  @note      统一标准，除初始化和终止之外进入每个函数时 SCL均应处于低电平，函数结束时也将SCL拉低
     25          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
     26          void GPIO_I2C_Init()
     27          {	
   \                     GPIO_I2C_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     28              static GPIO_InitTypeDef gpio_SDA_init_struct, gpio_SCL_init_struct;
     29              
     30          	//GPIO_Init(SDA_PORT, SDA_PIN, DIR_OUTPUT,OUTPUT_H);       //SDA
     31              gpio_SDA_init_struct.GPIO_PTx = SDA_PORT;
   \   00000002   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000004   0x....             LDR.N    R1,??DataTable7_1
   \   00000006   0x6008             STR      R0,[R1, #+0]
     32              gpio_SDA_init_struct.GPIO_Pins = SDA_PIN;                  //注意：初始化时得用GPIO_Pinx，而LPLD_GPIO_Output_b中直接用x
   \   00000008   0xF44F 0x4000      MOV      R0,#+32768
   \   0000000C   0x....             LDR.N    R1,??DataTable7_1
   \   0000000E   0x6048             STR      R0,[R1, #+4]
     33              gpio_SDA_init_struct.GPIO_Dir = DIR_OUTPUT;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable7_1
   \   00000014   0x7308             STRB     R0,[R1, #+12]
     34              gpio_SDA_init_struct.GPIO_Output = OUTPUT_H;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable7_1
   \   0000001A   0x7348             STRB     R0,[R1, #+13]
     35              gpio_SDA_init_struct.GPIO_PinControl = INPUT_PULL_UP;      //上拉
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0x....             LDR.N    R1,??DataTable7_1
   \   00000020   0x6088             STR      R0,[R1, #+8]
     36              LPLD_GPIO_Init(gpio_SDA_init_struct);    
   \   00000022   0x....             LDR.N    R1,??DataTable7_1
   \   00000024   0xB084             SUB      SP,SP,#+16
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x2214             MOVS     R2,#+20
   \   0000002A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002E   0xBC0F             POP      {R0-R3}
   \   00000030   0x.... 0x....      BL       LPLD_GPIO_Init
     37                  
     38          	//GPIO_Init(SCL_PORT, SCL_PIN, DIR_OUTPUT,OUTPUT_H);       //SCL
     39              gpio_SCL_init_struct.GPIO_PTx = SCL_PORT;
   \   00000034   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000036   0x....             LDR.N    R1,??DataTable7_2
   \   00000038   0x6008             STR      R0,[R1, #+0]
     40              gpio_SCL_init_struct.GPIO_Pins = SCL_PIN;                  //注意：初始化时得用GPIO_Pinx，而LPLD_GPIO_Output_b中直接用x
   \   0000003A   0xF44F 0x4080      MOV      R0,#+16384
   \   0000003E   0x....             LDR.N    R1,??DataTable7_2
   \   00000040   0x6048             STR      R0,[R1, #+4]
     41              gpio_SCL_init_struct.GPIO_Dir = DIR_OUTPUT;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable7_2
   \   00000046   0x7308             STRB     R0,[R1, #+12]
     42              gpio_SCL_init_struct.GPIO_Output = OUTPUT_H;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x....             LDR.N    R1,??DataTable7_2
   \   0000004C   0x7348             STRB     R0,[R1, #+13]
     43              gpio_SCL_init_struct.GPIO_PinControl = INPUT_PULL_UP;      //上拉
   \   0000004E   0x2003             MOVS     R0,#+3
   \   00000050   0x....             LDR.N    R1,??DataTable7_2
   \   00000052   0x6088             STR      R0,[R1, #+8]
     44              LPLD_GPIO_Init(gpio_SCL_init_struct);      
   \   00000054   0x....             LDR.N    R1,??DataTable7_2
   \   00000056   0xB084             SUB      SP,SP,#+16
   \   00000058   0x4668             MOV      R0,SP
   \   0000005A   0x2214             MOVS     R2,#+20
   \   0000005C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000060   0xBC0F             POP      {R0-R3}
   \   00000062   0x.... 0x....      BL       LPLD_GPIO_Init
     45              
     46          }
   \   00000066   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 4
   \                     `GPIO_I2C_Init::gpio_SDA_init_struct`:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
   \                     `GPIO_I2C_Init::gpio_SCL_init_struct`:
   \   00000000                      DS8 20
     47          
     48          /*===============================================================
     49          	@brief     开始信号
     50          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
     51          static void GPIO_I2C_Start()
     52          {
   \                     GPIO_I2C_Start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     53          	SET_SDA(HIGH);
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x210F             MOVS     R1,#+15
   \   00000006   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000008   0x.... 0x....      BL       LPLD_GPIO_Output_b
     54          	SCL_H;
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x210E             MOVS     R1,#+14
   \   00000010   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000012   0x.... 0x....      BL       LPLD_GPIO_Output_b
     55          	SET_SDA(LOW);	
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x210F             MOVS     R1,#+15
   \   0000001A   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   0000001C   0x.... 0x....      BL       LPLD_GPIO_Output_b
     56          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
     57          
     58          /*===============================================================
     59          	@brief     重新开始信号
     60          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
     61          static void GPIO_I2C_Restart()
     62          {
   \                     GPIO_I2C_Restart: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     63          	SET_SDA(HIGH);
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x210F             MOVS     R1,#+15
   \   00000006   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000008   0x.... 0x....      BL       LPLD_GPIO_Output_b
     64          	SCL_H;
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x210E             MOVS     R1,#+14
   \   00000010   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000012   0x.... 0x....      BL       LPLD_GPIO_Output_b
     65          	SET_SDA(LOW);	
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x210F             MOVS     R1,#+15
   \   0000001A   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   0000001C   0x.... 0x....      BL       LPLD_GPIO_Output_b
     66          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
     67          
     68          /*===============================================================
     69          	@brief     停止信号
     70          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
     71          static void GPIO_I2C_Stop()
     72          {
   \                     GPIO_I2C_Stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     73          	SET_SDA(LOW);
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x210F             MOVS     R1,#+15
   \   00000006   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000008   0x.... 0x....      BL       LPLD_GPIO_Output_b
     74          	SCL_H;
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x210E             MOVS     R1,#+14
   \   00000010   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000012   0x.... 0x....      BL       LPLD_GPIO_Output_b
     75          	SET_SDA(HIGH);	
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x210F             MOVS     R1,#+15
   \   0000001A   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   0000001C   0x.... 0x....      BL       LPLD_GPIO_Output_b
     76          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
     77          
     78          /*===============================================================
     79          	@brief     模拟写寄存器
     80          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
     81          static void GPIO_I2C_Write_Register(uint8 u8Data)
     82          {
   \                     GPIO_I2C_Write_Register: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     83          	uint8 u8BitTmp;
     84          	uint8 u8Loopi;
     85          	
     86          	for (u8Loopi=0; u8Loopi<8; u8Loopi++)
   \   00000004   0x2600             MOVS     R6,#+0
   \   00000006   0xE017             B.N      ??GPIO_I2C_Write_Register_0
     87          	{
     88          		u8BitTmp = (uint8)((u8Data >> (7-u8Loopi)) & 0x01); 
   \                     ??GPIO_I2C_Write_Register_1: (+1)
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0xF1D6 0x0007      RSBS     R0,R6,#+7
   \   0000000E   0x0021             MOVS     R1,R4
   \   00000010   0x4101             ASRS     R1,R1,R0
   \   00000012   0xF011 0x0501      ANDS     R5,R1,#0x1
     89                          SCL_L;
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x210E             MOVS     R1,#+14
   \   0000001A   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   0000001C   0x.... 0x....      BL       LPLD_GPIO_Output_b
     90                          SET_SDA(u8BitTmp);
   \   00000020   0x002A             MOVS     R2,R5
   \   00000022   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000024   0x210F             MOVS     R1,#+15
   \   00000026   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000028   0x.... 0x....      BL       LPLD_GPIO_Output_b
     91          		SCL_H;
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x210E             MOVS     R1,#+14
   \   00000030   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000032   0x.... 0x....      BL       LPLD_GPIO_Output_b
     92          	}
   \   00000036   0x1C76             ADDS     R6,R6,#+1
   \                     ??GPIO_I2C_Write_Register_0: (+1)
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x2E08             CMP      R6,#+8
   \   0000003C   0xDBE4             BLT.N    ??GPIO_I2C_Write_Register_1
     93          
     94          	SCL_L;  //第8字节时钟下降沿
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x210E             MOVS     R1,#+14
   \   00000042   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000044   0x.... 0x....      BL       LPLD_GPIO_Output_b
     95          	SET_SDA(HIGH); //释放总线以让从机可以应答
   \   00000048   0x2201             MOVS     R2,#+1
   \   0000004A   0x210F             MOVS     R1,#+15
   \   0000004C   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   0000004E   0x.... 0x....      BL       LPLD_GPIO_Output_b
     96          }
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
     97          
     98          /*===============================================================
     99          	@brief     模拟读寄存器
    100          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    101          static uint8 GPIO_I2C_Read_Register()
    102          {
   \                     GPIO_I2C_Read_Register: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    103          	uint8 u8Data = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    104          	uint8 u8BitTmp;
    105          	uint8 u8Loopi;
    106          	
    107          	SCL_L;  //交界处
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x210E             MOVS     R1,#+14
   \   00000008   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   0000000A   0x.... 0x....      BL       LPLD_GPIO_Output_b
    108          	SET_SDA(HIGH); //释放总线以让从机可以发送
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x210F             MOVS     R1,#+15
   \   00000012   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000014   0x.... 0x....      BL       LPLD_GPIO_Output_b
    109          
    110          	for (u8Loopi=0; u8Loopi<8; u8Loopi++)
   \   00000018   0x2500             MOVS     R5,#+0
   \   0000001A   0xE010             B.N      ??GPIO_I2C_Read_Register_0
    111          	{
    112          		SCL_H;
   \                     ??GPIO_I2C_Read_Register_1: (+1)
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0x210E             MOVS     R1,#+14
   \   00000020   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000022   0x.... 0x....      BL       LPLD_GPIO_Output_b
    113          		
    114                          u8BitTmp = GET_SDA();
   \   00000026   0x210F             MOVS     R1,#+15
   \   00000028   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   0000002A   0x.... 0x....      BL       LPLD_GPIO_Input_b
    115          		u8Data = (uint8)((u8Data<<1) | u8BitTmp);
   \   0000002E   0xEA50 0x0444      ORRS     R4,R0,R4, LSL #+1
    116          		SCL_L;		
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x210E             MOVS     R1,#+14
   \   00000036   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000038   0x.... 0x....      BL       LPLD_GPIO_Output_b
    117          	}	
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??GPIO_I2C_Read_Register_0: (+1)
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D08             CMP      R5,#+8
   \   00000042   0xDBEB             BLT.N    ??GPIO_I2C_Read_Register_1
    118          	
    119          	return u8Data;
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    120          }
    121          
    122          /*===============================================================
    123          	@brief     回复应答位信号
    124          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    125          static void GPIO_I2C_Response(uint8 u8AckState) //ACK_ON开启应答  ACK_OFF不应答
    126          {
   \                     GPIO_I2C_Response: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    127          	SCL_L; //交界处
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x210E             MOVS     R1,#+14
   \   00000008   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   0000000A   0x.... 0x....      BL       LPLD_GPIO_Output_b
    128          	SET_SDA(u8AckState);
   \   0000000E   0x0022             MOVS     R2,R4
   \   00000010   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000012   0x210F             MOVS     R1,#+15
   \   00000014   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000016   0x.... 0x....      BL       LPLD_GPIO_Output_b
    129          	SCL_H;
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x210E             MOVS     R1,#+14
   \   0000001E   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000020   0x.... 0x....      BL       LPLD_GPIO_Output_b
    130          	SCL_L;
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x210E             MOVS     R1,#+14
   \   00000028   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   0000002A   0x.... 0x....      BL       LPLD_GPIO_Output_b
    131          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    132          
    133          /*===============================================================
    134          	@brief     等待应答信号
    135          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    136          static uint8 GPIO_I2C_Wait_Ack() 
    137          {
   \                     GPIO_I2C_Wait_Ack: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    138          	uint8 u8AckRec;
    139          	uint32 u32Loopi = 0;
   \   00000002   0x2500             MOVS     R5,#+0
    140          	
    141          	SCL_H; //写“寄存器”操作时已经拉低
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x210E             MOVS     R1,#+14
   \   00000008   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   0000000A   0x.... 0x....      BL       LPLD_GPIO_Output_b
    142          	u8AckRec = GET_SDA();
   \   0000000E   0x210F             MOVS     R1,#+15
   \   00000010   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   00000012   0x.... 0x....      BL       LPLD_GPIO_Input_b
   \   00000016   0x0004             MOVS     R4,R0
   \   00000018   0xE000             B.N      ??GPIO_I2C_Wait_Ack_0
    143          	
    144          	while ((u8AckRec == 1) && (u32Loopi<3))
    145          	{
    146          		u32Loopi++;
   \                     ??GPIO_I2C_Wait_Ack_1: (+1)
   \   0000001A   0x1C6D             ADDS     R5,R5,#+1
    147          	}
   \                     ??GPIO_I2C_Wait_Ack_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C01             CMP      R4,#+1
   \   00000020   0xD101             BNE.N    ??GPIO_I2C_Wait_Ack_2
   \   00000022   0x2D03             CMP      R5,#+3
   \   00000024   0xD3F9             BCC.N    ??GPIO_I2C_Wait_Ack_1
    148          	
    149          	SCL_L;
   \                     ??GPIO_I2C_Wait_Ack_2: (+1)
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x210E             MOVS     R1,#+14
   \   0000002A   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff0c0
   \   0000002C   0x.... 0x....      BL       LPLD_GPIO_Output_b
    150          	
    151          	return u8AckRec;
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    152          }
    153          
    154          /*===============================================================
    155          	@brief     向总线设备发出1字节
    156          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    157          void GPIO_I2C_Write_1(uint8 DeviceAddr, uint8 AccessAddr, uint8 Data)
    158          {
   \                     GPIO_I2C_Write_1: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    159          	GPIO_I2C_Start(); //开始信号
   \   00000008   0x.... 0x....      BL       GPIO_I2C_Start
    160          	GPIO_I2C_Write_Register((uint8)(DeviceAddr & 0xfe)); //设备地址
   \   0000000C   0xF014 0x00FE      ANDS     R0,R4,#0xFE
   \   00000010   0x.... 0x....      BL       GPIO_I2C_Write_Register
    161          	GPIO_I2C_Wait_Ack(); //等待回应
   \   00000014   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    162          	GPIO_I2C_Write_Register(AccessAddr); //访问地址
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x.... 0x....      BL       GPIO_I2C_Write_Register
    163          	GPIO_I2C_Wait_Ack(); //等待回应
   \   00000020   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    164                  GPIO_I2C_Write_Register(Data); //写数据
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      BL       GPIO_I2C_Write_Register
    165          	GPIO_I2C_Wait_Ack(); //等待回应
   \   0000002C   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    166          	GPIO_I2C_Stop();		
   \   00000030   0x.... 0x....      BL       GPIO_I2C_Stop
    167          }
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
    168          
    169          /*===============================================================
    170          	@brief     从总线设备读取1字节
    171          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    172          uint8 GPIO_I2C_Read_1(uint8 DeviceAddr, uint8 AccessAddr, uint8 *pData)
    173          {
   \                     GPIO_I2C_Read_1: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    174              uint8 u8Temp;
    175              
    176          	GPIO_I2C_Start(); //开始信号
   \   00000008   0x.... 0x....      BL       GPIO_I2C_Start
    177          	GPIO_I2C_Write_Register((uint8)(DeviceAddr & 0xfe)); //设备地址，写操作
   \   0000000C   0xF014 0x00FE      ANDS     R0,R4,#0xFE
   \   00000010   0x.... 0x....      BL       GPIO_I2C_Write_Register
    178          	GPIO_I2C_Wait_Ack(); //等待回应
   \   00000014   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    179          	GPIO_I2C_Write_Register(AccessAddr); //访问地址
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x.... 0x....      BL       GPIO_I2C_Write_Register
    180          	GPIO_I2C_Wait_Ack(); //等待回应
   \   00000020   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    181          
    182          	GPIO_I2C_Restart(); //重新开始信号
   \   00000024   0x.... 0x....      BL       GPIO_I2C_Restart
    183          	GPIO_I2C_Write_Register((uint8)(DeviceAddr | 0x01)); // 写设备地址，为读模式，通知从机改为发送数据
   \   00000028   0xF054 0x0001      ORRS     R0,R4,#0x1
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      BL       GPIO_I2C_Write_Register
    184          	GPIO_I2C_Wait_Ack(); //等待回应
   \   00000032   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    185              
    186          	u8Temp = GPIO_I2C_Read_Register(); //读取数据
   \   00000036   0x.... 0x....      BL       GPIO_I2C_Read_Register
   \   0000003A   0x0004             MOVS     R4,R0
    187          	GPIO_I2C_Response(ACK_OFF); //非应答信号
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      BL       GPIO_I2C_Response
    188          	GPIO_I2C_Stop();
   \   00000042   0x.... 0x....      BL       GPIO_I2C_Stop
    189              
    190              if (pData != NULL)
   \   00000046   0x2E00             CMP      R6,#+0
   \   00000048   0xD000             BEQ.N    ??GPIO_I2C_Read_1_0
    191              {
    192                  *pData = u8Temp;
   \   0000004A   0x7034             STRB     R4,[R6, #+0]
    193              }
    194              
    195              return u8Temp;
   \                     ??GPIO_I2C_Read_1_0: (+1)
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
    196          }
    197          
    198          
    199          /*===============================================================
    200          	@brief     向总线设备发出2字节
    201          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    202          void GPIO_I2C_Write_2(uint8 DeviceAddr, uint8 AccessAddr, uint16 Data)
    203          {       
   \                     GPIO_I2C_Write_2: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    204                  uint8 msdata = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    205                  uint8 lsdata = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    206                  msdata = (uint8)((Data & 0xff00)>>8);
   \   0000000A   0x0010             MOVS     R0,R2
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0x0A06             LSRS     R6,R0,#+8
    207                  lsdata = (uint8)(Data & 0xff);
   \   00000010   0x0017             MOVS     R7,R2
    208                       
    209          	GPIO_I2C_Start(); //开始信号
   \   00000012   0x.... 0x....      BL       GPIO_I2C_Start
    210          	GPIO_I2C_Write_Register((uint8)(DeviceAddr & 0xfe)); //设备地址
   \   00000016   0xF014 0x00FE      ANDS     R0,R4,#0xFE
   \   0000001A   0x.... 0x....      BL       GPIO_I2C_Write_Register
    211          	GPIO_I2C_Wait_Ack(); //等待回应
   \   0000001E   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    212          	GPIO_I2C_Write_Register(AccessAddr); //访问地址
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       GPIO_I2C_Write_Register
    213          	GPIO_I2C_Wait_Ack(); //等待回应
   \   0000002A   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    214                  
    215                  GPIO_I2C_Write_Register(msdata); //写高八位数据
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       GPIO_I2C_Write_Register
    216          	GPIO_I2C_Wait_Ack(); //等待回应
   \   00000036   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    217                  GPIO_I2C_Write_Register(lsdata); //写低八位数据
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x.... 0x....      BL       GPIO_I2C_Write_Register
    218          	GPIO_I2C_Wait_Ack(); //等待回应
   \   00000042   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    219                  
    220          	GPIO_I2C_Stop();		
   \   00000046   0x.... 0x....      BL       GPIO_I2C_Stop
    221          }
   \   0000004A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    222          
    223          /*===============================================================
    224          	@brief     从总线设备读取2字节
    225          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    226          void GPIO_I2C_Read_2(uint8 DeviceAddr, uint8 AccessAddr, uint16 *pData)
    227          {
   \                     GPIO_I2C_Read_2: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    228                  uint16 msdata = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    229                  uint16 lsdata = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    230                  
    231          	GPIO_I2C_Start(); //开始信号
   \   00000010   0x.... 0x....      BL       GPIO_I2C_Start
    232          	GPIO_I2C_Write_Register((uint8)(DeviceAddr & 0xfe)); //设备地址，写操作
   \   00000014   0xF014 0x00FE      ANDS     R0,R4,#0xFE
   \   00000018   0x.... 0x....      BL       GPIO_I2C_Write_Register
    233          	GPIO_I2C_Wait_Ack(); //等待回应
   \   0000001C   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    234          	GPIO_I2C_Write_Register(AccessAddr); //访问地址
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x.... 0x....      BL       GPIO_I2C_Write_Register
    235          	GPIO_I2C_Wait_Ack(); //等待回应
   \   00000028   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    236          
    237          	GPIO_I2C_Restart(); //重新开始信号
   \   0000002C   0x.... 0x....      BL       GPIO_I2C_Restart
    238          	GPIO_I2C_Write_Register((uint8)(DeviceAddr | 0x01)); // 写设备地址，为读模式，通知从机改为发送数据
   \   00000030   0xF054 0x0001      ORRS     R0,R4,#0x1
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x.... 0x....      BL       GPIO_I2C_Write_Register
    239          	GPIO_I2C_Wait_Ack(); //等待回应
   \   0000003A   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    240                  
    241          	msdata = GPIO_I2C_Read_Register(); //读取高八位数据
   \   0000003E   0x.... 0x....      BL       GPIO_I2C_Read_Register
   \   00000042   0x0007             MOVS     R7,R0
    242                  GPIO_I2C_Response(ACK_ON); //应答信号
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x.... 0x....      BL       GPIO_I2C_Response
    243                  lsdata = GPIO_I2C_Read_Register(); //读取低八位数据
   \   0000004A   0x.... 0x....      BL       GPIO_I2C_Read_Register
   \   0000004E   0x4680             MOV      R8,R0
    244          	GPIO_I2C_Response(ACK_OFF); //非应答信号
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x.... 0x....      BL       GPIO_I2C_Response
    245                  
    246          	GPIO_I2C_Stop();
   \   00000056   0x.... 0x....      BL       GPIO_I2C_Stop
    247                  
    248                  *pData = ( (msdata<<8) | lsdata );      
   \   0000005A   0xEA58 0x2007      ORRS     R0,R8,R7, LSL #+8
   \   0000005E   0x8030             STRH     R0,[R6, #+0]
    249          }
   \   00000060   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    250          
    251          /*===============================================================
    252          	@brief     从总线设备读取N字节
    253          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    254          void GPIO_I2C_Read_N(uint8 DeviceAddr, uint8 AccessAddr, uint8 *pData, uint16 lenth)
    255          {
   \                     GPIO_I2C_Read_N: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    256                  int16 i = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    257                  
    258          	GPIO_I2C_Start(); //开始信号
   \   00000010   0x.... 0x....      BL       GPIO_I2C_Start
    259          	GPIO_I2C_Write_Register((uint8)(DeviceAddr & 0xfe)); //设备地址，写操作
   \   00000014   0xF014 0x00FE      ANDS     R0,R4,#0xFE
   \   00000018   0x.... 0x....      BL       GPIO_I2C_Write_Register
    260          	GPIO_I2C_Wait_Ack(); //等待回应
   \   0000001C   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    261          	GPIO_I2C_Write_Register(AccessAddr); //访问地址
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x.... 0x....      BL       GPIO_I2C_Write_Register
    262          	GPIO_I2C_Wait_Ack(); //等待回应
   \   00000028   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    263          
    264          	GPIO_I2C_Restart(); //重新开始信号
   \   0000002C   0x.... 0x....      BL       GPIO_I2C_Restart
    265          	GPIO_I2C_Write_Register((uint8)(DeviceAddr | 0x01)); // 写设备地址，为读模式，通知从机改为发送数据
   \   00000030   0xF054 0x0001      ORRS     R0,R4,#0x1
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x.... 0x....      BL       GPIO_I2C_Write_Register
    266          	GPIO_I2C_Wait_Ack(); //等待回应
   \   0000003A   0x.... 0x....      BL       GPIO_I2C_Wait_Ack
    267                  
    268                  for(i=0;i<lenth-1;i++)
   \   0000003E   0xF05F 0x0800      MOVS     R8,#+0
   \   00000042   0xE00A             B.N      ??GPIO_I2C_Read_N_0
    269                  {
    270                          pData[i] = GPIO_I2C_Read_Register(); //读取高八位数据
   \                     ??GPIO_I2C_Read_N_1: (+1)
   \   00000044   0x.... 0x....      BL       GPIO_I2C_Read_Register
   \   00000048   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   0000004C   0xF806 0x0008      STRB     R0,[R6, R8]
    271                          GPIO_I2C_Response(ACK_ON); //应答信号
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      BL       GPIO_I2C_Response
    272                  }
   \   00000056   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??GPIO_I2C_Read_N_0: (+1)
   \   0000005A   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   0000005E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000060   0x1E78             SUBS     R0,R7,#+1
   \   00000062   0x4580             CMP      R8,R0
   \   00000064   0xDBEE             BLT.N    ??GPIO_I2C_Read_N_1
    273                  pData[i] = GPIO_I2C_Read_Register(); //读取低八位数据
   \   00000066   0x.... 0x....      BL       GPIO_I2C_Read_Register
   \   0000006A   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   0000006E   0xF806 0x0008      STRB     R0,[R6, R8]
    274          	GPIO_I2C_Response(ACK_OFF); //非应答信号
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x.... 0x....      BL       GPIO_I2C_Response
    275                  
    276          	GPIO_I2C_Stop();
   \   00000078   0x.... 0x....      BL       GPIO_I2C_Stop
    277                  
    278                  //*pData = ( (msdata<<8) | lsdata );      
    279          }
   \   0000007C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    280          
    281          /*===============================================================
    282          	@brief     延时
    283          ==================================================================*/

   \                                 In section .text, align 2, keep-with-next
    284          void GPIO_I2C_Delay(uint32 u32DelayCnt)
    285          {
   \                     GPIO_I2C_Delay: (+1)
   \   00000000   0xE000             B.N      ??GPIO_I2C_Delay_0
    286              while(u32DelayCnt)
    287                u32DelayCnt--;
   \                     ??GPIO_I2C_Delay_1: (+1)
   \   00000002   0x1E40             SUBS     R0,R0,#+1
   \                     ??GPIO_I2C_Delay_0: (+1)
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD1FC             BNE.N    ??GPIO_I2C_Delay_1
    288          }    
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     `GPIO_I2C_Init::gpio_SDA_init_struct`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     `GPIO_I2C_Init::gpio_SCL_init_struct`

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GPIO_I2C_Delay
      24   GPIO_I2C_Init
         8   -> LPLD_GPIO_Init
        24   -> __aeabi_memcpy4
      16   GPIO_I2C_Read_1
        16   -> GPIO_I2C_Read_Register
        16   -> GPIO_I2C_Response
        16   -> GPIO_I2C_Restart
        16   -> GPIO_I2C_Start
        16   -> GPIO_I2C_Stop
        16   -> GPIO_I2C_Wait_Ack
        16   -> GPIO_I2C_Write_Register
      24   GPIO_I2C_Read_2
        24   -> GPIO_I2C_Read_Register
        24   -> GPIO_I2C_Response
        24   -> GPIO_I2C_Restart
        24   -> GPIO_I2C_Start
        24   -> GPIO_I2C_Stop
        24   -> GPIO_I2C_Wait_Ack
        24   -> GPIO_I2C_Write_Register
      24   GPIO_I2C_Read_N
        24   -> GPIO_I2C_Read_Register
        24   -> GPIO_I2C_Response
        24   -> GPIO_I2C_Restart
        24   -> GPIO_I2C_Start
        24   -> GPIO_I2C_Stop
        24   -> GPIO_I2C_Wait_Ack
        24   -> GPIO_I2C_Write_Register
      16   GPIO_I2C_Read_Register
        16   -> LPLD_GPIO_Input_b
        16   -> LPLD_GPIO_Output_b
       8   GPIO_I2C_Response
         8   -> LPLD_GPIO_Output_b
       8   GPIO_I2C_Restart
         8   -> LPLD_GPIO_Output_b
       8   GPIO_I2C_Start
         8   -> LPLD_GPIO_Output_b
       8   GPIO_I2C_Stop
         8   -> LPLD_GPIO_Output_b
      16   GPIO_I2C_Wait_Ack
        16   -> LPLD_GPIO_Input_b
        16   -> LPLD_GPIO_Output_b
      16   GPIO_I2C_Write_1
        16   -> GPIO_I2C_Start
        16   -> GPIO_I2C_Stop
        16   -> GPIO_I2C_Wait_Ack
        16   -> GPIO_I2C_Write_Register
      24   GPIO_I2C_Write_2
        24   -> GPIO_I2C_Start
        24   -> GPIO_I2C_Stop
        24   -> GPIO_I2C_Wait_Ack
        24   -> GPIO_I2C_Write_Register
      16   GPIO_I2C_Write_Register
        16   -> LPLD_GPIO_Output_b


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
      10  GPIO_I2C_Delay
     104  GPIO_I2C_Init
      82  GPIO_I2C_Read_1
     100  GPIO_I2C_Read_2
     128  GPIO_I2C_Read_N
      74  GPIO_I2C_Read_Register
      48  GPIO_I2C_Response
      34  GPIO_I2C_Restart
      34  GPIO_I2C_Start
      34  GPIO_I2C_Stop
      54  GPIO_I2C_Wait_Ack
      54  GPIO_I2C_Write_1
      76  GPIO_I2C_Write_2
      84  GPIO_I2C_Write_Register
      20  gpio_SCL_init_struct
      20  gpio_SDA_init_struct

 
  40 bytes in section .bss
 928 bytes in section .text
 
 928 bytes of CODE memory
  40 bytes of DATA memory

Errors: none
Warnings: none
